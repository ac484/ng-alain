---
alwaysApply: true
globs: mcp-redis.mdc
---

## 🧩 與 Cursor custom modes 的對應關係

| Custom Mode | 主要行為         | redis-mcp 參與方式                        |
|-------------|------------------|-------------------------------------------|
| VAN         | 快速查詢         | 先查 Redis 向量庫，命中則直接回傳           |
| PLAN        | 規劃/決策        | 新規劃/高頻查詢自動積累至 Redis             |
| CREATIVE    | 設計/多方案      | 設計決策/範例積累至 Redis                  |
| IMPLEMENT   | 進度/知識積累    | 新知識/bug/技術債高頻自動積累至 Redis       |
| REFLECT     | 回顧/優化        | 高頻教訓/優化建議積累至 Redis              |
| ARCHIVE     | 清理/淘汰        | 定期自動清理過期/低頻/低質量資料            |

## 🗺️ 流程圖
```mermaid
flowchart TD
    VAN[🔍 VAN: 快速查詢] --> redis[查 Redis 向量庫]
    redis -- 高相關 --> 回傳[直接回傳]
    redis -- 低相關/未命中 --> fallback[查 Memory-Flow/Bank/Context7]
    PLAN[📋 PLAN: 規劃決策] --> redis[積累新規劃/高頻查詢]
    CREATIVE[🎨 CREATIVE: 設計決策] --> redis[積累設計/範例]
    IMPLEMENT[⚒️ IMPLEMENT: 進度積累] --> redis[積累新知識/bug]
    REFLECT[🔍 REFLECT: 回顧優化] --> redis[積累教訓/優化]
    ARCHIVE[📦 ARCHIVE: 清理淘汰] --> 清理[自動清理/淘汰]
    redis --> 清理
```

## ✅ 標準步驟（對應各 mode）
1. **VAN**：查詢時先查 Redis 向量庫，命中則直接回傳
2. **PLAN/CREATIVE/IMPLEMENT/REFLECT**：新規劃/設計/進度/教訓等高頻知識自動積累至 Redis
3. **ARCHIVE**：定期自動清理過期/低頻/低質量資料

## 📝 範例命令/調用格式
- `get`: 查詢 Redis 快取
- `set`: 寫入/積累新知識
- `update`: 覆蓋/升級知識
- `delete`: 刪除資料
- `vector_search_hash`: 向量查詢

## 🌟 最佳實踐
- 僅高質量知識（如人工審核、質量分數高、查詢高頻）才寫入 Redis
- 寫入時自動生成向量 embedding，並存入 knowledge_vectors
- 若已存在同 id，則進行「覆蓋」或「版本升級」
- 定期（或根據事件）清理過期、低質量、重複資料
- 所有寫入/覆蓋/刪除操作有日誌可追溯
- Redis 只做快取與高頻知識庫，長期決策仍以 Memory-Bank/Flow 為主

## 🚦 典型觸發情境
- VAN：查詢 API/技術時，Redis 命中直接回傳
- PLAN：新規劃/高頻查詢自動積累
- CREATIVE：設計決策/範例積累
- IMPLEMENT：bug/技術債/新知識積累
- REFLECT：回顧教訓/優化積累
- ARCHIVE：週期性自動清理

## 🔗 整合建議
- 在各 custom_modes 的查詢/積累步驟自動觸發 redis-mcp
- 每個 mode 進入/切換時自動同步高頻知識至 Redis
- 定期自動清理過期/低質量資料，維持 Redis 健康

[[calls]]
match = """redis|cache|store|save|get|retrieve|set|hash|list|stream|json|pub|sub|zadd|sadd|lpush|rpush|hset|hget|vector|search|memory|session|queue"""
tool = "redis-mcp"

## 積累/寫入/更新/淘汰規則

- 僅高質量知識（如人工審核、質量分數高、查詢高頻）才寫入 Redis。
- Memory-Bank/Flow 有新決策時，主動同步到 Redis。
- 若知識內容有變更，則覆蓋原有資料（保留 version 與 updated_at）。
- 新知識明顯優於舊資料時，直接覆蓋（依質量分數、人工審核）。
- 定期（或根據事件）清理過期、低質量、重複資料。
- 支援 TTL（自動過期）、人工標記刪除、查詢頻率低自動淘汰。
- 刪除時同步移除向量索引。
- 每週自動統計 Redis 命中率、資料質量分布、查詢頻率。
- 低質量/過期/冷門資料自動淘汰。
- Memory-Bank/Flow 重大更新時，主動同步 Redis。
- 定期人工審查高頻知識，確保知識庫質量。

## 智能積累與自淨流程

```mermaid
flowchart TD
    N[新知識產生] --> Q[質量評分/審核]
    Q -- 高質量 --> V[生成向量/存入 Redis]
    Q -- 低質量 --> D[丟棄/不積累]
    V --> F{已存在同 id?}
    F -- 是 --> U[覆蓋/版本升級]
    F -- 否 --> S[新增]
    S & U --> L[記錄日誌]
    L --> R[定期清理/淘汰]
    R -->|過期/低質量/冷門| X[刪除]
    R -->|高頻/高質量| K[保留/升級]
```

## 偽代碼範例
```typescript
function accumulateToRedis(knowledge) {
  if (qualityScore(knowledge) < 0.8) return; // 低質量不積累
  const id = getKnowledgeId(knowledge);
  if (redis.exists(id)) {
    if (isBetter(knowledge, redis.get(id))) {
      redis.set(id, knowledge, { version: nextVersion(), updated_at: now() });
      log('覆蓋', id);
    }
  } else {
    redis.set(id, knowledge, { version: 1, created_at: now() });
    log('新增', id);
  }
}

function periodicCleanup() {
  for (const id of redis.keys()) {
    if (isExpired(id) || isLowQuality(id) || isLowFrequency(id)) {
      redis.delete(id);
      log('刪除', id);
    }
  }
}
```

> 本規範為 MCP Redis 向量知識庫最佳實踐，請團隊嚴格遵循，並根據實際需求持續優化。

match = """redis|cache|store|save|get|retrieve|set|hash|list|stream|json|pub|sub|zadd|sadd|lpush|rpush|hset|hget|vector|search|memory|session|queue"""
tool = "redis-mcp"
## 🧩 與 Cursor custom modes 的對應關係

| Custom Mode | 主要行為         | redis-mcp 參與方式                        |
|-------------|------------------|-------------------------------------------|
| VAN         | 快速查詢         | 先查 Redis 向量庫，命中則直接回傳           |
| PLAN        | 規劃/決策        | 新規劃/高頻查詢自動積累至 Redis             |
| CREATIVE    | 設計/多方案      | 設計決策/範例積累至 Redis                  |
| IMPLEMENT   | 進度/知識積累    | 新知識/bug/技術債高頻自動積累至 Redis       |
| REFLECT     | 回顧/優化        | 高頻教訓/優化建議積累至 Redis              |
| ARCHIVE     | 清理/淘汰        | 定期自動清理過期/低頻/低質量資料            |

## 🗺️ 流程圖
```mermaid
flowchart TD
    VAN[🔍 VAN: 快速查詢] --> redis[查 Redis 向量庫]
    redis -- 高相關 --> 回傳[直接回傳]
    redis -- 低相關/未命中 --> fallback[查 Memory-Flow/Bank/Context7]
    PLAN[📋 PLAN: 規劃決策] --> redis[積累新規劃/高頻查詢]
    CREATIVE[🎨 CREATIVE: 設計決策] --> redis[積累設計/範例]
    IMPLEMENT[⚒️ IMPLEMENT: 進度積累] --> redis[積累新知識/bug]
    REFLECT[🔍 REFLECT: 回顧優化] --> redis[積累教訓/優化]
    ARCHIVE[📦 ARCHIVE: 清理淘汰] --> 清理[自動清理/淘汰]
    redis --> 清理
```

## ✅ 標準步驟（對應各 mode）
1. **VAN**：查詢時先查 Redis 向量庫，命中則直接回傳
2. **PLAN/CREATIVE/IMPLEMENT/REFLECT**：新規劃/設計/進度/教訓等高頻知識自動積累至 Redis
3. **ARCHIVE**：定期自動清理過期/低頻/低質量資料

## 📝 範例命令/調用格式
- `get`: 查詢 Redis 快取
- `set`: 寫入/積累新知識
- `update`: 覆蓋/升級知識
- `delete`: 刪除資料
- `vector_search_hash`: 向量查詢

## 🌟 最佳實踐
- 僅高質量知識（如人工審核、質量分數高、查詢高頻）才寫入 Redis
- 寫入時自動生成向量 embedding，並存入 knowledge_vectors
- 若已存在同 id，則進行「覆蓋」或「版本升級」
- 定期（或根據事件）清理過期、低質量、重複資料
- 所有寫入/覆蓋/刪除操作有日誌可追溯
- Redis 只做快取與高頻知識庫，長期決策仍以 Memory-Bank/Flow 為主

## 🚦 典型觸發情境
- VAN：查詢 API/技術時，Redis 命中直接回傳
- PLAN：新規劃/高頻查詢自動積累
- CREATIVE：設計決策/範例積累
- IMPLEMENT：bug/技術債/新知識積累
- REFLECT：回顧教訓/優化積累
- ARCHIVE：週期性自動清理

## 🔗 整合建議
- 在各 custom_modes 的查詢/積累步驟自動觸發 redis-mcp
- 每個 mode 進入/切換時自動同步高頻知識至 Redis
- 定期自動清理過期/低質量資料，維持 Redis 健康

[[calls]]
match = """redis|cache|store|save|get|retrieve|set|hash|list|stream|json|pub|sub|zadd|sadd|lpush|rpush|hset|hget|vector|search|memory|session|queue"""
tool = "redis-mcp"

## 積累/寫入/更新/淘汰規則

- 僅高質量知識（如人工審核、質量分數高、查詢高頻）才寫入 Redis。
- Memory-Bank/Flow 有新決策時，主動同步到 Redis。
- 若知識內容有變更，則覆蓋原有資料（保留 version 與 updated_at）。
- 新知識明顯優於舊資料時，直接覆蓋（依質量分數、人工審核）。
- 定期（或根據事件）清理過期、低質量、重複資料。
- 支援 TTL（自動過期）、人工標記刪除、查詢頻率低自動淘汰。
- 刪除時同步移除向量索引。
- 每週自動統計 Redis 命中率、資料質量分布、查詢頻率。
- 低質量/過期/冷門資料自動淘汰。
- Memory-Bank/Flow 重大更新時，主動同步 Redis。
- 定期人工審查高頻知識，確保知識庫質量。

## 智能積累與自淨流程

```mermaid
flowchart TD
    N[新知識產生] --> Q[質量評分/審核]
    Q -- 高質量 --> V[生成向量/存入 Redis]
    Q -- 低質量 --> D[丟棄/不積累]
    V --> F{已存在同 id?}
    F -- 是 --> U[覆蓋/版本升級]
    F -- 否 --> S[新增]
    S & U --> L[記錄日誌]
    L --> R[定期清理/淘汰]
    R -->|過期/低質量/冷門| X[刪除]
    R -->|高頻/高質量| K[保留/升級]
```

## 偽代碼範例
```typescript
function accumulateToRedis(knowledge) {
  if (qualityScore(knowledge) < 0.8) return; // 低質量不積累
  const id = getKnowledgeId(knowledge);
  if (redis.exists(id)) {
    if (isBetter(knowledge, redis.get(id))) {
      redis.set(id, knowledge, { version: nextVersion(), updated_at: now() });
      log('覆蓋', id);
    }
  } else {
    redis.set(id, knowledge, { version: 1, created_at: now() });
    log('新增', id);
  }
}

function periodicCleanup() {
  for (const id of redis.keys()) {
    if (isExpired(id) || isLowQuality(id) || isLowFrequency(id)) {
      redis.delete(id);
      log('刪除', id);
    }
  }
}
```

> 本規範為 MCP Redis 向量知識庫最佳實踐，請團隊嚴格遵循，並根據實際需求持續優化。

match = """redis|cache|store|save|get|retrieve|set|hash|list|stream|json|pub|sub|zadd|sadd|lpush|rpush|hset|hget|vector|search|memory|session|queue"""
tool = "redis-mcp"
