import {
  NzFormDirective,
  NzFormItemComponent,
  NzFormModule
} from "./chunk-7M4YNMXT.js";
import {
  ArrayService
} from "./chunk-72WGOEKH.js";
import "./chunk-KG7WXLYY.js";
import {
  NzSwitchComponent,
  NzSwitchModule
} from "./chunk-FHN73A4J.js";
import {
  NzCardComponent,
  NzCardModule
} from "./chunk-64NBNGV7.js";
import {
  NzOptionComponent,
  NzOptionGroupComponent,
  NzSelectComponent,
  NzSelectModule
} from "./chunk-BO3C2WOT.js";
import {
  NzDatePickerComponent,
  NzDatePickerModule,
  NzMonthPickerComponent,
  NzRangePickerComponent,
  NzWeekPickerComponent,
  NzYearPickerComponent
} from "./chunk-5HPTFQGF.js";
import "./chunk-D4TKIAL4.js";
import {
  NzInputNumberComponent,
  NzInputNumberModule
} from "./chunk-7W2NXYCL.js";
import {
  NzAutosizeDirective,
  NzInputDirective,
  NzInputGroupComponent,
  NzInputGroupWhitSuffixOrPrefixDirective,
  NzInputModule,
  NzTextareaCountComponent
} from "./chunk-3Q5ZW3A4.js";
import "./chunk-NUIZUDC6.js";
import {
  NzColDirective,
  NzGridModule,
  NzRowDirective
} from "./chunk-ME3G4VH6.js";
import "./chunk-F2DXCIWC.js";
import "./chunk-OIOY4I4G.js";
import {
  NzRadioComponent,
  NzRadioGroupComponent,
  NzRadioModule
} from "./chunk-DLHTX2ZQ.js";
import {
  NzCheckboxComponent,
  NzCheckboxGroupComponent,
  NzCheckboxModule,
  NzCheckboxWrapperComponent
} from "./chunk-5CKH7BXE.js";
import {
  REGEX
} from "./chunk-BSLJP3PC.js";
import "./chunk-XPEPFKNH.js";
import {
  NzFormStatusService
} from "./chunk-JCLL7S6Q.js";
import {
  NzTooltipDirective,
  NzTooltipModule
} from "./chunk-4P4HHPBT.js";
import {
  ALAIN_I18N_TOKEN,
  DelonLocaleModule,
  DelonLocaleService
} from "./chunk-WLPEXMS5.js";
import {
  NzModalModule
} from "./chunk-V4XBV55A.js";
import "./chunk-ZTNECFVY.js";
import "./chunk-VCVGLQF3.js";
import "./chunk-HGGVII4K.js";
import "./chunk-C2DAT26Y.js";
import {
  NzButtonComponent,
  NzButtonModule
} from "./chunk-MKB5HFAJ.js";
import {
  NzWaveDirective
} from "./chunk-KEGEU5UL.js";
import {
  NzTransitionPatchDirective
} from "./chunk-FBEQODFK.js";
import "./chunk-HXEEJHXJ.js";
import "./chunk-QYDDKLT3.js";
import "./chunk-LE4RSIF3.js";
import {
  toDate
} from "./chunk-SQJ77OAJ.js";
import {
  ACLService
} from "./chunk-QZQ7SHKY.js";
import {
  format
} from "./chunk-BHH4M3PU.js";
import "./chunk-2BDLX2FQ.js";
import "./chunk-C6MTXAAB.js";
import "./chunk-U5VATZ4Q.js";
import "./chunk-EGGX2FJX.js";
import "./chunk-76DJI4FU.js";
import "./chunk-MIQKVNBS.js";
import {
  helpMotion
} from "./chunk-RH5RXJTD.js";
import "./chunk-Y5G3O3B7.js";
import {
  AlainConfigService
} from "./chunk-ES4WNO3Q.js";
import {
  deepCopy
} from "./chunk-XMKNXNVX.js";
import {
  NzIconDirective,
  NzIconModule
} from "./chunk-GP3H6RZA.js";
import "./chunk-OAOHUKFD.js";
import "./chunk-BQ76GOFF.js";
import "./chunk-LSG4V6ID.js";
import "./chunk-KG76OIXO.js";
import "./chunk-J25EALHE.js";
import "./chunk-FZ3LGF3I.js";
import "./chunk-LTANXE67.js";
import {
  DefaultValueAccessor,
  FormsModule,
  NgControlStatus,
  NgControlStatusGroup,
  NgForm,
  NgModel,
  ɵNgNoValidate
} from "./chunk-ZWI5T7AR.js";
import "./chunk-36PX2JTV.js";
import {
  DomSanitizer
} from "./chunk-BVIJPY5U.js";
import "./chunk-ZO4CS3CJ.js";
import {
  takeUntilDestroyed
} from "./chunk-I75K2H66.js";
import "./chunk-CQHDL44S.js";
import "./chunk-NDRILP3E.js";
import "./chunk-2WJ2IEY4.js";
import "./chunk-4NJAG2UW.js";
import "./chunk-IH6YTMYU.js";
import "./chunk-D4QSWQD6.js";
import "./chunk-NFHVISCS.js";
import "./chunk-TBGMZLZ3.js";
import {
  Platform
} from "./chunk-GIT7CFOZ.js";
import {
  CommonModule,
  NgTemplateOutlet
} from "./chunk-GUTSRBNM.js";
import "./chunk-FTJJFYDV.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  Directive,
  ElementRef,
  EventEmitter,
  HostBinding,
  Injectable,
  Input,
  NgModule,
  NgZone,
  Output,
  Renderer2,
  TemplateRef,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation,
  booleanAttribute,
  numberAttribute,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵconditional,
  ɵɵconditionalCreate,
  ɵɵdeclareLet,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineNgModule,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction3,
  ɵɵqueryRefresh,
  ɵɵreadContextLet,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵsanitizeHtml,
  ɵɵstoreLet,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-NQBXVTYU.js";
import {
  Injector,
  inject,
  makeEnvironmentProviders,
  provideEnvironmentInitializer,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵresetView,
  ɵɵrestoreView
} from "./chunk-QZDSTGXI.js";
import {
  merge
} from "./chunk-KMLKBNXJ.js";
import "./chunk-Q4VD2BBX.js";
import {
  BehaviorSubject,
  Observable,
  Subject,
  catchError,
  combineLatest,
  debounceTime,
  distinctUntilChanged,
  filter,
  map,
  of,
  switchMap,
  take,
  takeUntil
} from "./chunk-EBAU53KC.js";
import {
  __async,
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toESM
} from "./chunk-7CE4I3X6.js";

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? line : code_1.nil });
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : __spreadValues({}, this.lhs.names);
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = __spreadProps(__spreadValues({}, opts), { _n: opts.lines ? "\n" : "" });
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : __spreadValues(__spreadValues({}, from), to),
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: __spreadProps(__spreadValues({}, groups), { integer: true, boolean: true, null: true }),
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData2(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = __spreadProps(__spreadValues(__spreadValues({}, this.it), subschema), { items: void 0, props: void 0 });
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData2($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData2;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/scopedChars.js
var require_scopedChars = __commonJS({
  "node_modules/fast-uri/lib/scopedChars.js"(exports, module) {
    "use strict";
    var HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      A: 10,
      b: 11,
      B: 11,
      c: 12,
      C: 12,
      d: 13,
      D: 13,
      e: 14,
      E: 14,
      f: 15,
      F: 15
    };
    module.exports = {
      HEX
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var { HEX } = require_scopedChars();
    var IPV4_REG = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function normalizeIPv4(host) {
      if (findToken(host, ".") < 3) {
        return { host, isIPV4: false };
      }
      const matches = host.match(IPV4_REG) || [];
      const [address] = matches;
      if (address) {
        return { host: stripLeadingZeros(address, "."), isIPV4: true };
      } else {
        return { host, isIPV4: false };
      }
    }
    function stringArrayToHexStripped(input, keepZero = false) {
      let acc = "";
      let strip = true;
      for (const c of input) {
        if (HEX[c] === void 0) return void 0;
        if (c !== "0" && strip === true) strip = false;
        if (!strip) acc += c;
      }
      if (keepZero && acc.length === 0) acc = "0";
      return acc;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let isZone = false;
      let endipv6Encountered = false;
      let endIpv6 = false;
      function consume() {
        if (buffer.length) {
          if (isZone === false) {
            const hex = stringArrayToHexStripped(buffer);
            if (hex !== void 0) {
              address.push(hex);
            } else {
              output.error = true;
              return false;
            }
          }
          buffer.length = 0;
        }
        return true;
      }
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume()) {
            break;
          }
          tokenCount++;
          address.push(":");
          if (tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i - 1 >= 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          continue;
        } else if (cursor === "%") {
          if (!consume()) {
            break;
          }
          isZone = true;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (isZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv6 = getIPV6(host);
      if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
          newHost += "%" + ipv6.zone;
          escapedHost += "%25" + ipv6.zone;
        }
        return { host: newHost, escapedHost, isIPV6: true };
      } else {
        return { host, isIPV6: false };
      }
    }
    function stripLeadingZeros(str, token) {
      let out = "";
      let skip = true;
      const l = str.length;
      for (let i = 0; i < l; i++) {
        const c = str[i];
        if (c === "0" && skip) {
          if (i + 1 <= l && str[i + 1] === token || i + 1 === l) {
            out += c;
            skip = false;
          }
        } else {
          if (c === token) {
            skip = true;
          } else {
            skip = false;
          }
          out += c;
        }
      }
      return out;
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    var RDS1 = /^\.\.?\//u;
    var RDS2 = /^\/\.(?:\/|$)/u;
    var RDS3 = /^\/\.\.(?:\/|$)/u;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function removeDotSegments(input) {
      const output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          const im = input.match(RDS5);
          if (im) {
            const s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(components, esc) {
      const func = esc !== true ? escape : unescape;
      if (components.scheme !== void 0) {
        components.scheme = func(components.scheme);
      }
      if (components.userinfo !== void 0) {
        components.userinfo = func(components.userinfo);
      }
      if (components.host !== void 0) {
        components.host = func(components.host);
      }
      if (components.path !== void 0) {
        components.path = func(components.path);
      }
      if (components.query !== void 0) {
        components.query = func(components.query);
      }
      if (components.fragment !== void 0) {
        components.fragment = func(components.fragment);
      }
      return components;
    }
    function recomposeAuthority(components) {
      const uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        let host = unescape(components.host);
        const ipV4res = normalizeIPv4(host);
        if (ipV4res.isIPV4) {
          host = ipV4res.host;
        } else {
          const ipV6res = normalizeIPv6(ipV4res.host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = components.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      normalizeIPv4,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var UUID_REG = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu;
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function isSecure(wsComponents) {
      return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
    }
    function httpParse(components) {
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }
      return components;
    }
    function httpSerialize(components) {
      const secure = String(components.scheme).toLowerCase() === "https";
      if (components.port === (secure ? 443 : 80) || components.port === "") {
        components.port = void 0;
      }
      if (!components.path) {
        components.path = "/";
      }
      return components;
    }
    function wsParse(wsComponents) {
      wsComponents.secure = isSecure(wsComponents);
      wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
      wsComponents.path = void 0;
      wsComponents.query = void 0;
      return wsComponents;
    }
    function wsSerialize(wsComponents) {
      if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
        wsComponents.port = void 0;
      }
      if (typeof wsComponents.secure === "boolean") {
        wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
        wsComponents.secure = void 0;
      }
      if (wsComponents.resourceName) {
        const [path, query] = wsComponents.resourceName.split("?");
        wsComponents.path = path && path !== "/" ? path : void 0;
        wsComponents.query = query;
        wsComponents.resourceName = void 0;
      }
      wsComponents.fragment = void 0;
      return wsComponents;
    }
    function urnParse(urnComponents, options) {
      if (!urnComponents.path) {
        urnComponents.error = "URN can not be parsed";
        return urnComponents;
      }
      const matches = urnComponents.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponents.scheme || "urn";
        urnComponents.nid = matches[1].toLowerCase();
        urnComponents.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`;
        const schemeHandler = SCHEMES[urnScheme];
        urnComponents.path = void 0;
        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }
      return urnComponents;
    }
    function urnSerialize(urnComponents, options) {
      const scheme = options.scheme || urnComponents.scheme || "urn";
      const nid = urnComponents.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = SCHEMES[urnScheme];
      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }
      const uriComponents = urnComponents;
      const nss = urnComponents.nss;
      uriComponents.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponents;
    }
    function urnuuidParse(urnComponents, options) {
      const uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = void 0;
      if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }
      return uuidComponents;
    }
    function urnuuidSerialize(uuidComponents) {
      const urnComponents = uuidComponents;
      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
    var http = {
      scheme: "http",
      domainHost: true,
      parse: httpParse,
      serialize: httpSerialize
    };
    var https = {
      scheme: "https",
      domainHost: http.domainHost,
      parse: httpParse,
      serialize: httpSerialize
    };
    var ws = {
      scheme: "ws",
      domainHost: true,
      parse: wsParse,
      serialize: wsSerialize
    };
    var wss = {
      scheme: "wss",
      domainHost: ws.domainHost,
      parse: ws.parse,
      serialize: ws.serialize
    };
    var urn = {
      scheme: "urn",
      parse: urnParse,
      serialize: urnSerialize,
      skipNormalize: true
    };
    var urnuuid = {
      scheme: "urn:uuid",
      parse: urnuuidParse,
      serialize: urnuuidSerialize,
      skipNormalize: true
    };
    var SCHEMES = {
      http,
      https,
      ws,
      wss,
      urn,
      "urn:uuid": urnuuid
    };
    module.exports = SCHEMES;
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require_utils();
    var SCHEMES = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeof uri === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = Object.assign({ scheme: "null" }, options);
      const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
      return serialize(resolved, __spreadProps(__spreadValues({}, schemelessOptions), { skipEscape: true }));
    }
    function resolveComponents(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse(serialize(base, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), __spreadProps(__spreadValues({}, options), { skipEscape: true }));
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), __spreadProps(__spreadValues({}, options), { skipEscape: true }));
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), __spreadProps(__spreadValues({}, options), { skipEscape: true }));
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), __spreadProps(__spreadValues({}, options), { skipEscape: true }));
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const components = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
      if (components.path !== void 0) {
        if (!options.skipEscape) {
          components.path = escape(components.path);
          if (components.scheme !== void 0) {
            components.path = components.path.split("%3A").join(":");
          }
        } else {
          components.path = unescape(components.path);
        }
      }
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme, ":");
      }
      const authority = recomposeAuthority(components);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        let s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//u, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?", components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#", components.fragment);
      }
      return uriTokens.join("");
    }
    var hexLookUp = Array.from({ length: 127 }, (_v, k) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)));
    function nonSimpleDomain(value) {
      let code = 0;
      for (let i = 0, len = value.length; i < len; ++i) {
        code = value.charCodeAt(i);
        if (code > 126 || hexLookUp[code]) {
          return true;
        }
      }
      return false;
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      const gotEncoding = uri.indexOf("%") !== -1;
      let isIP = false;
      if (options.reference === "suffix") uri = (options.scheme ? options.scheme + ":" : "") + "//" + uri;
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = normalizeIPv4(parsed.host);
          if (ipv4result.isIPV4 === false) {
            const ipv6result = normalizeIPv6(ipv4result.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            parsed.host = ipv4result.host;
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (gotEncoding && parsed.scheme !== void 0) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (gotEncoding && parsed.host !== void 0) {
            parsed.host = unescape(parsed.host);
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponents,
      equal,
      serialize,
      parse
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? __spreadProps(__spreadValues({}, o.code), { optimize, regExp }) : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = __spreadValues(__spreadValues({}, opts), requiredOptions(opts));
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = __spreadValues({}, $dataRefSchema);
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        function runCompileAsync(_schema, _meta) {
          return __async(this, null, function* () {
            yield loadMetaSchema.call(this, _schema.$schema);
            const sch = this._addSchema(_schema, _meta);
            return sch.validate || _compileAsync.call(this, sch);
          });
        }
        function loadMetaSchema($ref) {
          return __async(this, null, function* () {
            if ($ref && !this.getSchema($ref)) {
              yield runCompileAsync.call(this, { $ref }, true);
            }
          });
        }
        function _compileAsync(sch) {
          return __async(this, null, function* () {
            try {
              return this._compileSchemaEnv(sch);
            } catch (e) {
              if (!(e instanceof ref_error_1.default))
                throw e;
              checkLoaded.call(this, e);
              yield loadMissingSchema.call(this, e.missingSchema);
              return _compileAsync.call(this, sch);
            }
          });
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        function loadMissingSchema(ref) {
          return __async(this, null, function* () {
            const _schema = yield _loadSchema.call(this, ref);
            if (!this.refs[ref])
              yield loadMetaSchema.call(this, _schema.$schema);
            if (!this.refs[ref])
              this.addSchema(_schema, ref, meta);
          });
        }
        function _loadSchema(ref) {
          return __async(this, null, function* () {
            const p = this._loading[ref];
            if (p)
              return p;
            try {
              return yield this._loading[ref] = loadSchema(ref);
            } finally {
              delete this._loading[ref];
            }
          });
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = __spreadProps(__spreadValues({}, def), {
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        });
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format2) {
        if (typeof format2 == "string")
          format2 = new RegExp(format2);
        this.formats[name] = format2;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format2 = this.opts.formats[name];
        if (format2)
          this.addFormat(name, format2);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = __spreadValues({}, this.opts);
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: __spreadProps(__spreadValues({}, definition), {
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        })
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format2 = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format2, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format2, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format2}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format2}(${data}) : ${format2}(${data}))` : (0, codegen_1._)`${format2}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format2} == "function" ? ${callFormat} : ${format2}.test(${data}))`;
            return (0, codegen_1._)`${format2} && ${format2} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format2, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format2 == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format2 = [format_1.default];
    exports.default = format2;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = __spreadProps(__spreadValues({}, exports.fullFormats), {
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    });
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format2 = fCxt.schema;
          const fmtDef = self.formats[format2];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format2}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format2,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format2)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats2(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats2(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats2(ajv, list, fs, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// node_modules/@delon/form/fesm2022/form.mjs
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist(), 1);
var _c0 = ["target"];
function SFItemComponent_ng_template_0_Template(rf, ctx) {
}
function SFItemComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
var _c1 = ["*"];
function SFComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-icon", 11);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(5);
    ɵɵproperty("nzType", ctx_r1._btn.submit_icon.type)("nzTheme", ctx_r1._btn.submit_icon.theme)("nzTwotoneColor", ctx_r1._btn.submit_icon.twoToneColor)("nzIconfont", ctx_r1._btn.submit_icon.iconfont);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-icon", 11);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const resetIcon_r4 = ɵɵreadContextLet(1);
    ɵɵproperty("nzType", resetIcon_r4.type)("nzTheme", resetIcon_r4.theme)("nzTwotoneColor", resetIcon_r4.twoToneColor)("nzIconfont", resetIcon_r4.iconfont);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13);
    ɵɵlistener("click", function SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Conditional_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1.reset(true));
    });
    ɵɵdeclareLet(1);
    ɵɵconditionalCreate(2, SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Conditional_3_Conditional_2_Template, 1, 4, "nz-icon", 11);
    ɵɵtext(3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(3);
    const btnRender_r5 = ɵɵreadContextLet(0);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("nzType", ctx_r1._btn.reset_type)("nzSize", btnRender_r5.size)("disabled", ctx_r1.loading);
    ɵɵadvance();
    const resetIcon_r6 = ɵɵstoreLet(ctx_r1._btn.reset_icon);
    ɵɵadvance();
    ɵɵconditional(resetIcon_r6 ? 2 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1._btn.reset, " ");
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 10);
    ɵɵconditionalCreate(1, SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Conditional_1_Template, 1, 4, "nz-icon", 11);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Conditional_3_Template, 4, 6, "button", 12);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const btnRender_r5 = ɵɵreadContextLet(0);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("nzType", ctx_r1._btn.submit_type)("nzSize", btnRender_r5.size)("nzLoading", ctx_r1.loading)("disabled", ctx_r1.liveValidate && !ctx_r1.valid);
    ɵɵadvance();
    ɵɵconditional(ctx_r1._btn.submit_icon ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1._btn.submit, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r1._btn.reset ? 3 : -1);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_5_ng_template_0_Template(rf, ctx) {
}
function SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_5_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    ɵɵnextContext(4);
    const con_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", con_r7);
  }
}
function SFComponent_ng_template_2_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-form-item", 6)(1, "div", 7)(2, "div", 8)(3, "div", 9);
    ɵɵconditionalCreate(4, SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_4_Template, 4, 7)(5, SFComponent_ng_template_2_Conditional_0_Conditional_1_Conditional_5_Template, 1, 1, null, 4);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const btnRender_r5 = ɵɵreadContextLet(0);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(btnRender_r5.class);
    ɵɵproperty("fixed-label", btnRender_r5.spanLabelFixed);
    ɵɵadvance();
    ɵɵproperty("nzSpan", ctx_r1.btnGrid.span)("nzOffset", ctx_r1.btnGrid.offset)("nzXs", ctx_r1.btnGrid.xs)("nzSm", ctx_r1.btnGrid.sm)("nzMd", ctx_r1.btnGrid.md)("nzLg", ctx_r1.btnGrid.lg)("nzXl", ctx_r1.btnGrid.xl)("nzXXl", ctx_r1.btnGrid.xxl);
    ɵɵadvance(3);
    ɵɵconditional(ctx_r1.button ? 4 : 5);
  }
}
function SFComponent_ng_template_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵdeclareLet(0);
    ɵɵconditionalCreate(1, SFComponent_ng_template_2_Conditional_0_Conditional_1_Template, 6, 12, "nz-form-item", 5);
  }
  if (rf & 2) {
    const btnRender_r8 = ɵɵstoreLet(ɵɵnextContext(2)._btn.render);
    ɵɵadvance();
    ɵɵconditional(btnRender_r8 ? 1 : -1);
  }
}
function SFComponent_ng_template_2_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function SFComponent_ng_template_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, SFComponent_ng_template_2_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const con_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", con_r7);
  }
}
function SFComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, SFComponent_ng_template_2_Conditional_0_Template, 2, 2)(1, SFComponent_ng_template_2_Conditional_1_Template, 1, 1, null, 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.button !== "none" ? 0 : 1);
  }
}
function SFComponent_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "sf-item", 3);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const btnTpl_r9 = ɵɵreference(3);
    ɵɵproperty("formProperty", ctx_r1.rootProperty)("footer", btnTpl_r9);
  }
}
function SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-icon", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("nzTooltipTitle", ctx_r0.oh.text)("nzTooltipPlacement", ctx_r0.oh.placement)("nzTooltipTrigger", ctx_r0.oh.trigger)("nzTooltipColor", ctx_r0.oh.bgColor)("nzTooltipOverlayClassName", ctx_r0.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r0.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r0.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r0.oh.mouseLeaveDelay)("nzType", ctx_r0.oh.icon);
  }
}
function SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵconditionalCreate(2, SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Conditional_2_Template, 1, 9, "nz-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r0.oh ? 2 : -1);
  }
}
function SFItemWrapComponent_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label")(1, "span", 7);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵconditionalCreate(3, SFItemWrapComponent_Conditional_1_Conditional_1_Conditional_3_Template, 3, 2, "span", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassProp("ant-form-item-required", ctx_r0.ui._required);
    ɵɵattribute("for", ctx_r0.id);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.t);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.ui.optional || ctx_r0.oh ? 3 : -1);
  }
}
function SFItemWrapComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 0);
    ɵɵconditionalCreate(1, SFItemWrapComponent_Conditional_1_Conditional_1_Template, 4, 5, "label", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("nzSpan", ctx_r0.ui.spanLabel);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.t ? 1 : -1);
  }
}
function SFItemWrapComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4)(1, "div", 10);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@helpMotion", void 0);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.error, " ");
  }
}
function SFItemWrapComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.ui._description, ɵɵsanitizeHtml);
  }
}
function ArrayWidget_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-icon", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("nzTooltipTitle", ctx_r1.oh.text)("nzTooltipPlacement", ctx_r1.oh.placement)("nzTooltipTrigger", ctx_r1.oh.trigger)("nzTooltipOverlayClassName", ctx_r1.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r1.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r1.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r1.oh.mouseLeaveDelay)("nzType", ctx_r1.oh.icon);
  }
}
function ArrayWidget_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 0)(1, "label");
    ɵɵtext(2);
    ɵɵelementStart(3, "span", 6);
    ɵɵtext(4);
    ɵɵconditionalCreate(5, ArrayWidget_Conditional_1_Conditional_5_Template, 1, 8, "nz-icon", 7);
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 8)(7, "button", 9);
    ɵɵlistener("click", function ArrayWidget_Conditional_1_Template_button_click_7_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.addItem());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("nzSpan", ctx_r1.ui.spanLabel);
    ɵɵadvance();
    ɵɵclassProp("ant-form-item-required", ctx_r1.ui.required);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.schema.title, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r1.oh ? 5 : -1);
    ɵɵadvance(2);
    ɵɵproperty("nzType", ctx_r1.addType)("disabled", ctx_r1.addDisabled)("innerHTML", ctx_r1.addTitle, ɵɵsanitizeHtml);
  }
}
function ArrayWidget_For_6_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13);
    ɵɵlistener("click", function ArrayWidget_For_6_Conditional_0_Conditional_3_Template_span_click_0_listener() {
      ɵɵrestoreView(_r3);
      const $index_r4 = ɵɵnextContext(2).$index;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.removeItem($index_r4));
    });
    ɵɵelement(1, "nz-icon", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵattribute("title", ctx_r1.removeTitle);
  }
}
function ArrayWidget_For_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10)(1, "nz-card");
    ɵɵelement(2, "sf-item", 11);
    ɵɵconditionalCreate(3, ArrayWidget_For_6_Conditional_0_Conditional_3_Template, 2, 1, "span", 12);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const i_r6 = ctx_r4.$implicit;
    const $index_r4 = ctx_r4.$index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("nzSpan", ctx_r1.arraySpan);
    ɵɵattribute("data-index", $index_r4);
    ɵɵadvance(2);
    ɵɵproperty("formProperty", i_r6);
    ɵɵadvance();
    ɵɵconditional(ctx_r1.showRemove ? 3 : -1);
  }
}
function ArrayWidget_For_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ArrayWidget_For_6_Conditional_0_Template, 4, 4, "div", 10);
  }
  if (rf & 2) {
    const i_r6 = ctx.$implicit;
    ɵɵconditional(i_r6.visible && !i_r6.ui.hidden ? 0 : -1);
  }
}
function ArrayWidget_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.error);
  }
}
function ArrayWidget_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r1.ui._description, ɵɵsanitizeHtml);
  }
}
function CheckboxWidget_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 3);
    ɵɵtwoWayListener("ngModelChange", function CheckboxWidget_ng_template_0_Conditional_0_Template_label_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.allChecked, $event) || (ctx_r1.allChecked = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function CheckboxWidget_ng_template_0_Conditional_0_Template_label_ngModelChange_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onAllChecked());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtwoWayProperty("ngModel", ctx_r1.allChecked);
    ɵɵproperty("nzIndeterminate", ctx_r1.indeterminate);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.ui.checkAllText || ctx_r1.l.checkAllText, " ");
  }
}
function CheckboxWidget_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CheckboxWidget_ng_template_0_Conditional_0_Template, 2, 3, "label", 2);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.ui.checkAll ? 0 : -1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-icon", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("nzTooltipTitle", ctx_r1.oh.text)("nzTooltipPlacement", ctx_r1.oh.placement)("nzTooltipTrigger", ctx_r1.oh.trigger)("nzTooltipOverlayClassName", ctx_r1.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r1.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r1.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r1.oh.mouseLeaveDelay)("nzType", ctx_r1.oh.icon);
  }
}
function CheckboxWidget_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "label", 5);
    ɵɵlistener("ngModelChange", function CheckboxWidget_Conditional_3_Conditional_0_Template_label_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._setValue($event));
    });
    ɵɵtext(1);
    ɵɵelementStart(2, "span", 6);
    ɵɵtext(3);
    ɵɵconditionalCreate(4, CheckboxWidget_Conditional_3_Conditional_0_Conditional_4_Template, 1, 8, "nz-icon", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("nzDisabled", ctx_r1.disabled)("ngModel", ctx_r1.value);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.schema.title, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r1.oh ? 4 : -1);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵtemplate(0, CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 9);
    ɵɵelementStart(1, "nz-checkbox-group", 10);
    ɵɵlistener("ngModelChange", function CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template_nz_checkbox_group_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.groupInGridChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    const all_r5 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", all_r5);
    ɵɵadvance();
    ɵɵproperty("ngModel", ctx_r1.value)("nzOptions", ctx_r1.data);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_ng_template_1_Template(rf, ctx) {
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    const all_r5 = ɵɵreference(1);
    ɵɵproperty("nzSpan", ctx_r1.grid_span);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", all_r5);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_For_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13)(1, "label", 14);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const i_r7 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("nzSpan", ctx_r1.grid_span);
    ɵɵadvance();
    ɵɵproperty("nzValue", i_r7.value)("ngModel", i_r7.checked)("nzDisabled", i_r7.disabled);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", i_r7.label, " ");
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-checkbox-wrapper", 11);
    ɵɵlistener("nzOnChange", function CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template_nz_checkbox_wrapper_nzOnChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.groupInGridChange($event));
    });
    ɵɵelementStart(1, "div", 12);
    ɵɵconditionalCreate(2, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Conditional_2_Template, 2, 2, "div", 13);
    ɵɵrepeaterCreate(3, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_For_4_Template, 3, 5, "div", 13, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵconditional(ctx_r1.ui.checkAll ? 2 : -1);
    ɵɵadvance();
    ɵɵrepeater(ctx_r1.data);
  }
}
function CheckboxWidget_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CheckboxWidget_Conditional_3_Conditional_1_Conditional_0_Template, 2, 3)(1, CheckboxWidget_Conditional_3_Conditional_1_Conditional_1_Template, 5, 1, "nz-checkbox-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵconditional(ctx_r1.grid_span === 0 ? 0 : 1);
  }
}
function CheckboxWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, CheckboxWidget_Conditional_3_Conditional_0_Template, 5, 5, "label", 4)(1, CheckboxWidget_Conditional_3_Conditional_1_Template, 2, 1);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵconditional(ctx_r1.data.length === 0 ? 0 : 1);
  }
}
var _c2 = (a0, a1, a2) => ({
  $implicit: a0,
  schema: a1,
  ui: a2
});
function CustomWidget_ng_template_1_Template(rf, ctx) {
}
function DateWidget_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-year-picker", 5);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_1_Template_nz_year_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.displayValue, $event) || (ctx_r1.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_1_Template_nz_year_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._change($event));
    })("nzOnOpenChange", function DateWidget_Case_1_Template_nz_year_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._openChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.ui.className);
    ɵɵproperty("nzId", ctx_r1.id)("nzDisabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzFormat", ctx_r1.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r1.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r1.i.allowClear)("nzDisabledDate", ctx_r1.ui.disabledDate)("nzLocale", ctx_r1.ui.locale)("nzPlaceHolder", ctx_r1.ui.placeholder)("nzPopupStyle", ctx_r1.ui.popupStyle)("nzDropdownClassName", ctx_r1.ui.dropdownClassName)("nzRenderExtraFooter", ctx_r1.ui.renderExtraFooter)("nzInputReadOnly", ctx_r1.ui.inputReadOnly)("nzInline", ctx_r1.ui.inline);
  }
}
function DateWidget_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-month-picker", 5);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_2_Template_nz_month_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.displayValue, $event) || (ctx_r1.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_2_Template_nz_month_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._change($event));
    })("nzOnOpenChange", function DateWidget_Case_2_Template_nz_month_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._openChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.ui.className);
    ɵɵproperty("nzId", ctx_r1.id)("nzDisabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzFormat", ctx_r1.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r1.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r1.i.allowClear)("nzDisabledDate", ctx_r1.ui.disabledDate)("nzLocale", ctx_r1.ui.locale)("nzPlaceHolder", ctx_r1.ui.placeholder)("nzPopupStyle", ctx_r1.ui.popupStyle)("nzDropdownClassName", ctx_r1.ui.dropdownClassName)("nzRenderExtraFooter", ctx_r1.ui.renderExtraFooter)("nzInputReadOnly", ctx_r1.ui.inputReadOnly)("nzInline", ctx_r1.ui.inline);
  }
}
function DateWidget_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-week-picker", 6);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_3_Template_nz_week_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.displayValue, $event) || (ctx_r1.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_3_Template_nz_week_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._change($event));
    })("nzOnOpenChange", function DateWidget_Case_3_Template_nz_week_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._openChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.ui.className);
    ɵɵproperty("nzId", ctx_r1.id)("nzDisabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzFormat", ctx_r1.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r1.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r1.i.allowClear)("nzDisabledDate", ctx_r1.ui.disabledDate)("nzLocale", ctx_r1.ui.locale)("nzPlaceHolder", ctx_r1.ui.placeholder)("nzPopupStyle", ctx_r1.ui.popupStyle)("nzDropdownClassName", ctx_r1.ui.dropdownClassName)("nzInputReadOnly", ctx_r1.ui.inputReadOnly)("nzInline", ctx_r1.ui.inline);
  }
}
function DateWidget_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-range-picker", 7);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_4_Template_nz_range_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.displayValue, $event) || (ctx_r1.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_4_Template_nz_range_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._change($event));
    })("nzOnOpenChange", function DateWidget_Case_4_Template_nz_range_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._openChange($event));
    })("nzOnOk", function DateWidget_Case_4_Template_nz_range_picker_nzOnOk_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._ok($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.ui.className);
    ɵɵproperty("nzId", ctx_r1.id)("nzDisabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzFormat", ctx_r1.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r1.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r1.i.allowClear)("nzDisabledDate", ctx_r1.ui.disabledDate)("nzLocale", ctx_r1.ui.locale)("nzPlaceHolder", ctx_r1.ui.placeholder)("nzPopupStyle", ctx_r1.ui.popupStyle)("nzDropdownClassName", ctx_r1.ui.dropdownClassName)("nzDisabledTime", ctx_r1.ui.disabledTime)("nzRenderExtraFooter", ctx_r1.ui.renderExtraFooter)("nzRanges", ctx_r1.ui.ranges)("nzShowTime", ctx_r1.ui.showTime)("nzSeparator", ctx_r1.ui.separator)("nzShowWeekNumber", ctx_r1.ui.showWeekNumber || false)("nzMode", ctx_r1.ui.rangeMode)("nzInputReadOnly", ctx_r1.ui.inputReadOnly)("nzInline", ctx_r1.ui.inline);
  }
}
function DateWidget_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-date-picker", 8);
    ɵɵtwoWayListener("ngModelChange", function DateWidget_Case_5_Template_nz_date_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.displayValue, $event) || (ctx_r1.displayValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("ngModelChange", function DateWidget_Case_5_Template_nz_date_picker_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._change($event));
    })("nzOnOpenChange", function DateWidget_Case_5_Template_nz_date_picker_nzOnOpenChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._openChange($event));
    })("nzOnOk", function DateWidget_Case_5_Template_nz_date_picker_nzOnOk_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._ok($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.ui.className);
    ɵɵproperty("nzId", ctx_r1.id)("nzDisabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzFormat", ctx_r1.displayFormat);
    ɵɵtwoWayProperty("ngModel", ctx_r1.displayValue);
    ɵɵproperty("nzAllowClear", ctx_r1.i.allowClear)("nzDisabledDate", ctx_r1.ui.disabledDate)("nzLocale", ctx_r1.ui.locale)("nzPlaceHolder", ctx_r1.ui.placeholder)("nzPopupStyle", ctx_r1.ui.popupStyle)("nzDropdownClassName", ctx_r1.ui.dropdownClassName)("nzDisabledTime", ctx_r1.ui.disabledTime)("nzRenderExtraFooter", ctx_r1.ui.renderExtraFooter)("nzShowTime", ctx_r1.ui.showTime)("nzShowToday", ctx_r1.i.showToday)("nzShowWeekNumber", ctx_r1.ui.showWeekNumber || false)("nzInputReadOnly", ctx_r1.ui.inputReadOnly)("nzInline", ctx_r1.ui.inline);
  }
}
var _c3 = () => [];
var _c4 = () => ({
  $implicit: true
});
function ObjectWidget_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.title);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵelement(1, "sf-item", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r2 = ɵɵnextContext().$implicit;
    ɵɵproperty("nzSpan", i_r2.grid.span)("nzOffset", i_r2.grid.offset)("nzXs", i_r2.grid.xs)("nzSm", i_r2.grid.sm)("nzMd", i_r2.grid.md)("nzLg", i_r2.grid.lg)("nzXl", i_r2.grid.xl)("nzXXl", i_r2.grid.xxl);
    ɵɵadvance();
    ɵɵproperty("formProperty", i_r2.property)("fixed-label", i_r2.spanLabelFixed);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ObjectWidget_ng_template_0_Conditional_1_For_2_Conditional_0_Template, 2, 10, "div", 6);
  }
  if (rf & 2) {
    const i_r2 = ctx.$implicit;
    ɵɵconditional(i_r2.property.visible && i_r2.show ? 0 : -1);
  }
}
function ObjectWidget_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵrepeaterCreate(1, ObjectWidget_ng_template_0_Conditional_1_For_2_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("nzGutter", ctx_r0.grid.gutter);
    ɵɵadvance();
    ɵɵrepeater(ctx_r0.list);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "sf-item", 7);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext().$implicit;
    ɵɵproperty("formProperty", i_r3.property)("fixed-label", i_r3.spanLabelFixed);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ObjectWidget_ng_template_0_Conditional_2_For_1_Conditional_0_Template, 1, 2, "sf-item", 7);
  }
  if (rf & 2) {
    const i_r3 = ctx.$implicit;
    ɵɵconditional(i_r3.property.visible && i_r3.show ? 0 : -1);
  }
}
function ObjectWidget_ng_template_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, ObjectWidget_ng_template_0_Conditional_2_For_1_Template, 1, 1, null, null, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵrepeater(ctx_r0.list);
  }
}
function ObjectWidget_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵconditionalCreate(0, ObjectWidget_ng_template_0_Conditional_0_Template, 2, 1, "div", 4);
    ɵɵconditionalCreate(1, ObjectWidget_ng_template_0_Conditional_1_Template, 3, 1, "div", 5)(2, ObjectWidget_ng_template_0_Conditional_2_Template, 2, 0);
  }
  if (rf & 2) {
    const noTitle_r4 = ctx.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵconditional(!noTitle_r4 && ctx_r0.title ? 0 : -1);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.grid ? 1 : 2);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-icon", 11);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("nzType", ctx_r0.expand ? "down" : "up");
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-icon", 13);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(4);
    ɵɵproperty("nzTooltipTitle", ctx_r0.oh.text)("nzTooltipPlacement", ctx_r0.oh.placement)("nzTooltipTrigger", ctx_r0.oh.trigger)("nzTooltipColor", ctx_r0.oh.bgColor)("nzTooltipOverlayClassName", ctx_r0.oh.overlayClassName)("nzTooltipOverlayStyle", ctx_r0.oh.overlayStyle)("nzTooltipMouseEnterDelay", ctx_r0.oh.mouseEnterDelay)("nzTooltipMouseLeaveDelay", ctx_r0.oh.mouseLeaveDelay)("nzType", ctx_r0.oh.icon);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtext(1);
    ɵɵconditionalCreate(2, ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Conditional_2_Template, 1, 9, "nz-icon", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.ui.optional, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r0.oh ? 2 : -1);
  }
}
function ObjectWidget_Conditional_2_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10);
    ɵɵlistener("click", function ObjectWidget_Conditional_2_ng_template_1_Template_div_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0.changeExpand());
    });
    ɵɵconditionalCreate(1, ObjectWidget_Conditional_2_ng_template_1_Conditional_1_Template, 1, 1, "nz-icon", 11);
    ɵɵtext(2);
    ɵɵconditionalCreate(3, ObjectWidget_Conditional_2_ng_template_1_Conditional_3_Template, 3, 2, "span", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassProp("point", ctx_r0.showExpand);
    ɵɵadvance();
    ɵɵconditional(ctx_r0.showExpand ? 1 : -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.title, " ");
    ɵɵadvance();
    ɵɵconditional(ctx_r0.ui.optional || ctx_r0.oh ? 3 : -1);
  }
}
function ObjectWidget_Conditional_2_ng_template_3_Template(rf, ctx) {
}
function ObjectWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-card", 8);
    ɵɵtemplate(1, ObjectWidget_Conditional_2_ng_template_1_Template, 4, 5, "ng-template", null, 1, ɵɵtemplateRefExtractor)(3, ObjectWidget_Conditional_2_ng_template_3_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const cardTitleTpl_r6 = ɵɵreference(2);
    const ctx_r0 = ɵɵnextContext();
    const default_r7 = ɵɵreference(1);
    ɵɵclassProp("sf__object-card-fold", !ctx_r0.expand);
    ɵɵproperty("nzTitle", cardTitleTpl_r6)("nzExtra", ctx_r0.ui.cardExtra)("nzSize", ctx_r0.ui.cardSize || "small")("nzActions", ctx_r0.ui.cardActions || ɵɵpureFunction0(10, _c3))("nzBodyStyle", ctx_r0.ui.cardBodyStyle)("nzBordered", ctx_r0.ui.cardBordered || true);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", default_r7)("ngTemplateOutletContext", ɵɵpureFunction0(11, _c4));
  }
}
function ObjectWidget_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function ObjectWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ObjectWidget_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const default_r7 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", default_r7);
  }
}
function RadioWidget_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 2);
    ɵɵelement(1, "span", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("nzValue", option_r1.value)("nzDisabled", ctx_r1.disabled || option_r1.disabled);
    ɵɵadvance();
    ɵɵproperty("innerHTML", option_r1.label, ɵɵsanitizeHtml);
  }
}
function RadioWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, RadioWidget_Conditional_2_For_1_Template, 2, 3, "label", 2, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.data);
  }
}
function RadioWidget_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 4);
    ɵɵelement(1, "span", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r3 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("nzValue", option_r3.value)("nzDisabled", ctx_r1.disabled || option_r3.disabled);
    ɵɵadvance();
    ɵɵproperty("innerHTML", option_r3.label, ɵɵsanitizeHtml);
  }
}
function RadioWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, RadioWidget_Conditional_3_For_1_Template, 2, 3, "label", 4, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.data);
  }
}
function SelectWidget_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-option", 3);
  }
  if (rf & 2) {
    const o_r1 = ctx.$implicit;
    ɵɵproperty("nzLabel", o_r1.label)("nzValue", o_r1.value)("nzHide", o_r1.hide)("nzDisabled", o_r1.disabled);
  }
}
function SelectWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SelectWidget_Conditional_2_For_1_Template, 1, 4, "nz-option", 3, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.data);
  }
}
function SelectWidget_Conditional_3_For_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "nz-option", 5);
  }
  if (rf & 2) {
    const o_r3 = ctx.$implicit;
    ɵɵproperty("nzLabel", o_r3.label)("nzValue", o_r3.value)("nzDisabled", o_r3.disabled)("nzHide", o_r3.hide);
  }
}
function SelectWidget_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-option-group", 4);
    ɵɵrepeaterCreate(1, SelectWidget_Conditional_3_For_1_For_2_Template, 1, 4, "nz-option", 5, ɵɵrepeaterTrackByIndex);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r4 = ctx.$implicit;
    ɵɵproperty("nzLabel", i_r4.label);
    ɵɵadvance();
    ɵɵrepeater(i_r4.children);
  }
}
function SelectWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵrepeaterCreate(0, SelectWidget_Conditional_3_For_1_Template, 3, 1, "nz-option-group", 4, ɵɵrepeaterTrackByIndex);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵrepeater(ctx_r1.data);
  }
}
function SelectWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-option", 2);
    ɵɵelement(1, "nz-icon", 6);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.ui.searchLoadingText, " ");
  }
}
function StringWidget_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 4);
    ɵɵlistener("ngModelChange", function StringWidget_ng_template_1_Template_input_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.change($event));
    })("keyup.enter", function StringWidget_ng_template_1_Template_input_keyup_enter_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.enter($event));
    })("focus", function StringWidget_ng_template_1_Template_input_focus_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focus($event));
    })("blur", function StringWidget_ng_template_1_Template_input_blur_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.blur($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("nzBorderless", ctx_r1.ui.borderless)("ngModel", ctx_r1.value);
    ɵɵattribute("id", ctx_r1.id)("disabled", ctx_r1.disabled)("maxLength", ctx_r1.schema.maxLength || null)("type", ctx_r1.ui.type || "text")("placeholder", ctx_r1.ui.placeholder)("autocomplete", ctx_r1.ui.autocomplete)("autoFocus", ctx_r1.ui.autofocus);
  }
}
function StringWidget_Conditional_3_ng_template_1_Template(rf, ctx) {
}
function StringWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "nz-input-group", 2);
    ɵɵtemplate(1, StringWidget_Conditional_3_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const ipt_r3 = ɵɵreference(2);
    ɵɵproperty("nzAddOnBefore", ctx_r1.ui.addOnBefore)("nzAddOnAfter", ctx_r1.ui.addOnAfter)("nzAddOnBeforeIcon", ctx_r1.ui.addOnBeforeIcon)("nzAddOnAfterIcon", ctx_r1.ui.addOnAfterIcon)("nzPrefix", ctx_r1.ui.prefix)("nzPrefixIcon", ctx_r1.ui.prefixIcon)("nzSuffix", ctx_r1.ui.suffix)("nzSuffixIcon", ctx_r1.ui.suffixIcon);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ipt_r3);
  }
}
function StringWidget_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function StringWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, StringWidget_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const ipt_r3 = ɵɵreference(2);
    ɵɵproperty("ngTemplateOutlet", ipt_r3);
  }
}
function TextWidget_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerHTML", ctx_r0.text, ɵɵsanitizeHtml);
  }
}
function TextWidget_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("innerText", ctx_r0.text);
  }
}
function TextareaWidget_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "textarea", 4);
    ɵɵlistener("ngModelChange", function TextareaWidget_ng_template_1_Template_textarea_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.change($event));
    })("focus", function TextareaWidget_ng_template_1_Template_textarea_focus_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focus($event));
    })("blur", function TextareaWidget_ng_template_1_Template_textarea_blur_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.blur($event));
    });
    ɵɵtext(1, "      ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("ngModel", ctx_r1.value)("nzAutosize", ctx_r1.autosize)("nzBorderless", ctx_r1.ui.borderless);
    ɵɵattribute("id", ctx_r1.id)("disabled", ctx_r1.disabled)("maxLength", ctx_r1.schema.maxLength || null)("placeholder", ctx_r1.ui.placeholder);
  }
}
function TextareaWidget_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "nz-textarea-count", 2)(1, "textarea", 4);
    ɵɵlistener("ngModelChange", function TextareaWidget_Conditional_3_Template_textarea_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.change($event));
    })("focus", function TextareaWidget_Conditional_3_Template_textarea_focus_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focus($event));
    })("blur", function TextareaWidget_Conditional_3_Template_textarea_blur_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.blur($event));
    });
    ɵɵtext(2, "        ");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("nzMaxCharacterCount", ctx_r1.ui.maxCharacterCount)("nzComputeCharacterCount", ctx_r1.ui.computeCharacterCount);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.disabled)("nzSize", ctx_r1.ui.size)("ngModel", ctx_r1.value)("nzAutosize", ctx_r1.autosize)("nzBorderless", ctx_r1.ui.borderless);
    ɵɵattribute("id", ctx_r1.id)("disabled", ctx_r1.disabled)("maxLength", ctx_r1.schema.maxLength || null)("placeholder", ctx_r1.ui.placeholder);
  }
}
function TextareaWidget_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function TextareaWidget_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TextareaWidget_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const ipt_r4 = ɵɵreference(2);
    ɵɵproperty("ngTemplateOutlet", ipt_r4);
  }
}
var SF_DEFAULT_CONFIG = {
  formatMap: {
    "date-time": {
      widget: "date",
      showTime: true,
      format: `yyyy-MM-dd'T'HH:mm:ss.SSSxxx`
    },
    date: {
      widget: "date",
      format: "yyyy-MM-dd"
    },
    "full-date": {
      widget: "date",
      format: "yyyy-MM-dd"
    },
    time: {
      widget: "time",
      format: "HH:mm:ss.SSSxxx"
    },
    "full-time": {
      widget: "time"
    },
    week: {
      widget: "date",
      mode: "week",
      format: "yyyy-ww"
    },
    month: {
      widget: "date",
      mode: "month",
      format: "yyyy-MM"
    },
    uri: {
      widget: "upload"
    },
    email: {
      widget: "autocomplete",
      type: "email"
    },
    color: {
      widget: "string",
      type: "color"
    },
    "": {
      widget: "string"
    }
  },
  ingoreKeywords: ["type", "enum"],
  liveValidate: true,
  autocomplete: null,
  firstVisual: false,
  onlyVisual: false,
  errors: {},
  ui: {},
  button: {
    submit_type: "primary",
    reset_type: "default"
  },
  uiDateStringFormat: "yyyy-MM-dd HH:mm:ss",
  uiDateNumberFormat: "T",
  uiTimeStringFormat: "HH:mm:ss",
  uiTimeNumberFormat: "T",
  uiEmailSuffixes: ["qq.com", "163.com", "gmail.com", "126.com", "aliyun.com"],
  delay: false
};
function mergeConfig(srv) {
  return srv.merge("sf", SF_DEFAULT_CONFIG);
}
var SF_SEQ = "/";
function isBlank(o) {
  return o == null;
}
function toBool(value, defaultValue) {
  return value == null ? defaultValue : `${value}` !== "false";
}
function di(ui, ...args) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (ui.debug) {
      console.warn(...args);
    }
  }
}
function findSchemaDefinition($ref, definitions) {
  const match = /^#\/definitions\/(.*)$/.exec($ref);
  if (match && match[1]) {
    const parts = match[1].split(SF_SEQ);
    let current = definitions;
    for (let part of parts) {
      part = part.replace(/~1/g, SF_SEQ).replace(/~0/g, "~");
      if (Object.prototype.hasOwnProperty.call(current, part)) {
        current = current[part];
      } else {
        throw new Error(`Could not find a definition for ${$ref}.`);
      }
    }
    return current;
  }
  throw new Error(`Could not find a definition for ${$ref}.`);
}
function retrieveSchema(schema, definitions = {}) {
  if (Object.prototype.hasOwnProperty.call(schema, "$ref")) {
    const $refSchema = findSchemaDefinition(schema.$ref, definitions);
    const _a = schema, {
      $ref
    } = _a, localSchema = __objRest(_a, [
      "$ref"
    ]);
    return retrieveSchema(__spreadValues(__spreadValues({}, $refSchema), localSchema), definitions);
  }
  return schema;
}
function resolveIfSchema(_schema, _ui) {
  const fn = (schema, ui) => {
    resolveIf(schema, ui);
    Object.keys(schema.properties).forEach((key) => {
      const property = schema.properties[key];
      const uiKey = `$${key}`;
      if (property.items) {
        fn(property.items, ui[uiKey].$items);
      }
      if (property.properties) {
        fn(property, ui[uiKey]);
      }
    });
  };
  fn(_schema, _ui);
}
function resolveIf(schema, ui) {
  if (!(Object.prototype.hasOwnProperty.call(schema, "if") && Object.prototype.hasOwnProperty.call(schema, "then"))) return null;
  if (!schema.if.properties) throw new Error(`if: does not contain 'properties'`);
  const allKeys = Object.keys(schema.properties);
  const ifKeys = Object.keys(schema.if.properties);
  detectKey(allKeys, ifKeys);
  detectKey(allKeys, schema.then.required);
  schema.required = schema.required.concat(schema.then.required);
  const hasElse = Object.prototype.hasOwnProperty.call(schema, "else");
  if (hasElse) {
    detectKey(allKeys, schema.else.required);
    schema.required = schema.required.concat(schema.else.required);
  }
  const visibleIf = {};
  const visibleElse = {};
  ifKeys.forEach((key) => {
    const cond = schema.if.properties[key].enum;
    visibleIf[key] = cond;
    if (hasElse) visibleElse[key] = (value) => !cond.includes(value);
  });
  schema.then.required.forEach((key) => ui[`$${key}`].visibleIf = visibleIf);
  if (hasElse) {
    schema.else.required.forEach((key) => ui[`$${key}`].visibleIf = visibleElse);
  }
  return schema;
}
function detectKey(keys, detectKeys) {
  detectKeys.forEach((key) => {
    if (!keys.includes(key)) {
      throw new Error(`if: properties does not contain '${key}'`);
    }
  });
}
function orderProperties(properties, order) {
  if (!Array.isArray(order)) return properties;
  const arrayToHash = (arr) => arr.reduce((prev, curr) => {
    prev[curr] = true;
    return prev;
  }, {});
  const errorPropList = (arr) => `property [${arr.join(`', '`)}]`;
  const propertyHash = arrayToHash(properties);
  const orderHash = arrayToHash(order);
  const extraneous = order.filter((prop) => prop !== "*" && !propertyHash[prop]);
  if (extraneous.length) {
    throw new Error(`ui schema order list contains extraneous ${errorPropList(extraneous)}`);
  }
  const rest = properties.filter((prop) => !orderHash[prop]);
  const restIndex = order.indexOf("*");
  if (restIndex === -1) {
    if (rest.length) {
      throw new Error(`ui schema order list does not contain ${errorPropList(rest)}`);
    }
    return order;
  }
  if (restIndex !== order.lastIndexOf("*")) {
    throw new Error("ui schema order list contains more than one wildcard item");
  }
  const complete = [...order];
  complete.splice(restIndex, 1, ...rest);
  return complete;
}
function getEnum(list, formData, readOnly) {
  if (isBlank(list) || !Array.isArray(list) || list.length === 0) return [];
  if (typeof list[0] !== "object") {
    list = list.map((item) => {
      return {
        label: item,
        value: item
      };
    });
  }
  if (formData) {
    if (!Array.isArray(formData)) formData = [formData];
    list.forEach((item) => {
      if (~formData.indexOf(item.value)) item.checked = true;
    });
  }
  if (readOnly) {
    list.forEach((item) => item.disabled = true);
  }
  return list;
}
function getCopyEnum(list, formData, readOnly) {
  return getEnum(deepCopy(list || []), formData, readOnly);
}
function getData(schema, ui, formData, asyncArgs) {
  if (typeof ui.asyncData === "function") {
    return ui.asyncData(asyncArgs).pipe(map((list) => getCopyEnum(list, formData, schema.readOnly)));
  }
  return of(getCopyEnum(schema.enum, formData, schema.readOnly));
}
function isDateFns(srv) {
  if (!srv) return false;
  const data = srv.getDateLocale();
  return data != null && !!data.formatDistance;
}
var FormProperty = class {
  injector;
  _options;
  _errors = null;
  _valueChanges = new BehaviorSubject({
    path: null,
    pathValue: null,
    value: null
  });
  _errorsChanges = new BehaviorSubject(null);
  _visible = true;
  _visibilityChanges = new BehaviorSubject(true);
  _root;
  _parent;
  _objErrors = {};
  schemaValidator;
  schema;
  ui;
  formData;
  _value = null;
  widget;
  path;
  propertyId;
  constructor(injector, schemaValidatorFactory, schema, ui, formData, parent, path, _options) {
    this.injector = injector;
    this._options = _options;
    this.schema = schema;
    this.ui = ui;
    this.schemaValidator = schemaValidatorFactory.createValidatorFn(schema, {
      ingoreKeywords: this.ui.ingoreKeywords,
      debug: ui.debug
    });
    this.formData = formData || schema.default;
    this._parent = parent;
    if (parent) {
      this._root = parent.root;
    } else {
      this._root = this;
    }
    this.path = path;
  }
  get valueChanges() {
    return this._valueChanges;
  }
  get errorsChanges() {
    return this._errorsChanges;
  }
  get type() {
    return this.schema.type;
  }
  get parent() {
    return this._parent;
  }
  get root() {
    return this._root;
  }
  get value() {
    return this._value;
  }
  get errors() {
    return this._errors;
  }
  get visible() {
    return this._visible;
  }
  get valid() {
    return this._errors === null || this._errors.length === 0;
  }
  get options() {
    return this._options;
  }
  cd(onlySelf = false) {
    this.widget?.detectChanges(onlySelf);
  }
  /**
   * 更新值且校验数据
   */
  updateValueAndValidity(options) {
    options = __spreadValues({
      onlySelf: false,
      emitValidator: true,
      emitValueEvent: true,
      updatePath: "",
      updateValue: null
    }, options);
    this._updateValue();
    if (options.emitValueEvent) {
      options.updatePath = options.updatePath || this.path;
      options.updateValue = options.updateValue == null ? this.value : options.updateValue;
      this.valueChanges.next({
        value: this.value,
        path: options.updatePath,
        pathValue: options.updateValue
      });
    }
    if (options.emitValidator && this.ui.liveValidate === true) {
      this._runValidation();
    }
    if (this.parent && !options.onlySelf) {
      this.parent.updateValueAndValidity(__spreadProps(__spreadValues({}, options), {
        emitValidator: false
      }));
    }
  }
  /** 根据路径搜索表单属性 */
  searchProperty(path) {
    let prop = this;
    let base = null;
    let result = null;
    if (path[0] === SF_SEQ) {
      base = this.findRoot();
      result = base.getProperty(path.substring(1));
    } else {
      while (result === null && prop.parent !== null) {
        prop = base = prop.parent;
        result = base.getProperty(path);
      }
    }
    return result;
  }
  /** 查找根表单属性 */
  findRoot() {
    let property = this;
    while (property.parent !== null) {
      property = property.parent;
    }
    return property;
  }
  // #region process errors
  isEmptyData(value) {
    if (isBlank(value)) return true;
    switch (this.type) {
      case "string":
        return `${value}`.length === 0;
    }
    return false;
  }
  /**
   * @internal
   */
  _runValidation() {
    let errors;
    const isEmpty = this.isEmptyData(this._value);
    if (isEmpty && this.ui._required) {
      errors = [{
        keyword: "required"
      }];
    } else if (isEmpty) {
      errors = [];
    } else {
      errors = this.schemaValidator(this._value) || [];
    }
    const customValidator = this.ui.validator;
    if (typeof customValidator === "function") {
      const customErrors = customValidator(this.value, this, this.findRoot());
      if (customErrors instanceof Observable) {
        customErrors.subscribe((res) => {
          this.setCustomErrors(errors, res);
          this.cd(false);
        });
        return;
      }
      this.setCustomErrors(errors, customErrors);
      return;
    }
    this._errors = errors;
    this.setErrors(this._errors);
  }
  setCustomErrors(errors, list) {
    const hasCustomError = Array.isArray(list) && list.length > 0;
    if (hasCustomError) {
      list.forEach((err) => {
        if (!err.message) {
          throw new Error(`The custom validator must contain a 'message' attribute to viewed error text`);
        }
        err.keyword = null;
      });
    }
    this._errors = hasCustomError ? errors.concat(...list) : errors;
    this.setErrors(this._errors);
  }
  /**
   * Set the current error message
   *
   * 设置当前错误消息
   *
   * @param emitFormat 若提供的消息带有 `{xx}` 会自动根据参数进行转化，包含自定义函数
   *
   * @example
   *
   * this.sf.getProperty('/name')?.setErrors({ keyword: 'required' });
   * this.sf.getProperty('/name')?.setErrors({ message: 'Please input your username!' });
   * this.sf.getProperty('/name')?.setErrors(); // Clean error
   */
  setErrors(errors = [], emitFormat = true) {
    let arrErrs = Array.isArray(errors) ? errors : [errors];
    if (emitFormat && arrErrs && !this.ui.onlyVisual) {
      const l = this.widget && this.widget.l.error || {};
      arrErrs = arrErrs.map((err) => {
        let message = err.keyword == null && err.message ? err.message : (this.ui.errors || {})[err.keyword] || this._options.errors[err.keyword] || l[err.keyword] || ``;
        if (message && typeof message === "function") {
          message = message(err);
        }
        if (message) {
          if (~message.indexOf("{") && err.params) {
            message = message.replace(/{([.a-zA-Z0-9]+)}/g, (_v, key) => err.params[key] || "");
          }
          err.message = message;
        }
        return err;
      });
    }
    this._errors = arrErrs;
    this._errorsChanges.next(arrErrs);
    if (this._parent) {
      this._parent.setParentAndPlatErrors(arrErrs, this.path);
    }
  }
  setParentAndPlatErrors(errors, path) {
    this._objErrors[path] = errors;
    const platErrors = [];
    Object.keys(this._objErrors).forEach((p) => {
      const property = this.searchProperty(p);
      if (property && !property.visible) return;
      platErrors.push(...this._objErrors[p]);
    });
    this.setErrors(platErrors, false);
  }
  // #endregion
  // #region condition
  /**
   * Set the hide or display of widget
   * 设置小部件的隐藏或显示
   */
  setVisible(visible) {
    this._visible = visible;
    this._visibilityChanges.next(visible);
    if (visible) {
      this.injector.get(NgZone).onStable.pipe(take(1)).subscribe(() => {
        this.resetValue(this.value, true);
      });
    }
    return this;
  }
  _bindVisibility() {
    const visibleIf = this.ui.visibleIf;
    if (typeof visibleIf === "object" && Object.keys(visibleIf).length === 0) {
      this.setVisible(false);
    } else if (visibleIf != null) {
      const propertiesBinding = [];
      for (const dependencyPath in visibleIf) {
        if (Object.prototype.hasOwnProperty.call(visibleIf, dependencyPath)) {
          const property = this.searchProperty(dependencyPath);
          if (property) {
            const valueCheck = property.valueChanges.pipe(map((res) => {
              const vi = visibleIf[dependencyPath];
              if (typeof vi === "function") {
                const viFnRes = vi(res.value, property);
                if (typeof viFnRes === "object") {
                  const fixViFnRes = __spreadValues({
                    show: false,
                    required: false
                  }, viFnRes);
                  const parentRequired = this.parent?.schema.required;
                  if (parentRequired && this.propertyId) {
                    const idx = parentRequired.findIndex((w) => w === this.propertyId);
                    if (fixViFnRes.required) {
                      if (idx === -1) parentRequired.push(this.propertyId);
                    } else {
                      if (idx !== -1) parentRequired.splice(idx, 1);
                    }
                    this.ui._required = fixViFnRes.required;
                  }
                  return fixViFnRes.show;
                }
                return viFnRes;
              }
              if (vi.indexOf("$ANY$") !== -1) {
                return res.value && res.value.length > 0;
              } else {
                return vi.indexOf(res.value) !== -1;
              }
            }));
            const visibilityCheck = property._visibilityChanges;
            const and = combineLatest([valueCheck, visibilityCheck]).pipe(map((results) => results[0] && results[1]));
            propertiesBinding.push(and);
          } else {
            if (typeof ngDevMode === "undefined" || ngDevMode) {
              console.warn(`Can't find property ${dependencyPath} for visibility check of ${this.path}`);
            }
          }
        }
      }
      combineLatest(propertiesBinding).pipe(map((values) => this.ui.visibleIfLogical === "and" ? values.every((v) => v) : values.some((v) => v)), distinctUntilChanged()).subscribe((visible) => this.setVisible(visible));
    }
  }
  // #endregion
  updateFeedback(status = "") {
    this.ui.feedback = status;
    this.widget?.injector.get(NzFormStatusService).formStatusChanges.next({
      status,
      hasFeedback: !!status
    });
    this.cd(true);
  }
};
var PropertyGroup = class _PropertyGroup extends FormProperty {
  properties = null;
  getProperty(path) {
    const subPathIdx = path.indexOf(SF_SEQ);
    const propertyId = subPathIdx !== -1 ? path.substring(0, subPathIdx) : path;
    let property = this.properties[propertyId];
    if (property !== null && subPathIdx !== -1 && property instanceof _PropertyGroup) {
      const subPath = path.substring(subPathIdx + 1);
      property = property.getProperty(subPath);
    }
    return property;
  }
  forEachChild(fn) {
    for (const propertyId in this.properties) {
      if (Object.prototype.hasOwnProperty.call(this.properties, propertyId)) {
        const property = this.properties[propertyId];
        fn(property, propertyId);
      }
    }
  }
  forEachChildRecursive(fn) {
    this.forEachChild((child) => {
      fn(child);
      if (child instanceof _PropertyGroup) {
        child.forEachChildRecursive(fn);
      }
    });
  }
  _bindVisibility() {
    super._bindVisibility();
    this._bindVisibilityRecursive();
  }
  _bindVisibilityRecursive() {
    this.forEachChildRecursive((property) => {
      property._bindVisibility();
    });
  }
  isRoot() {
    return this === this.root;
  }
};
var ObjectProperty = class extends PropertyGroup {
  formPropertyFactory;
  _propertiesId = [];
  get propertiesId() {
    return this._propertiesId;
  }
  constructor(injector, formPropertyFactory, schemaValidatorFactory, schema, ui, formData, parent, path, options) {
    super(injector, schemaValidatorFactory, schema, ui, formData, parent, path, options);
    this.formPropertyFactory = formPropertyFactory;
    this.createProperties();
  }
  createProperties() {
    this.properties = {};
    this._propertiesId = [];
    let orderedProperties;
    try {
      orderedProperties = orderProperties(Object.keys(this.schema.properties), this.ui.order);
    } catch (e) {
      console.error(`Invalid ${this.schema.title || "root"} object field configuration:`, e);
    }
    orderedProperties.forEach((propertyId) => {
      this.properties[propertyId] = this.formPropertyFactory.createProperty(this.schema.properties[propertyId], this.ui[`$${propertyId}`], (this.formData || {})[propertyId], this, propertyId);
      this._propertiesId.push(propertyId);
    });
  }
  setValue(value, onlySelf) {
    const properties = this.properties;
    for (const propertyId in value) {
      if (Object.prototype.hasOwnProperty.call(value, propertyId) && properties[propertyId]) {
        properties[propertyId].setValue(value[propertyId], true);
      }
    }
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    value = value || this.schema.default || {};
    const properties = this.properties;
    for (const propertyId in this.schema.properties) {
      if (Object.prototype.hasOwnProperty.call(this.schema.properties, propertyId)) {
        properties[propertyId].resetValue(value[propertyId], true);
      }
    }
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  _hasValue() {
    return this.value != null && !!Object.keys(this.value).length;
  }
  _updateValue() {
    const value = {};
    this.forEachChild((property, propertyId) => {
      if (property.visible && property._hasValue()) {
        value[propertyId] = property.value;
      }
    });
    this._value = value;
  }
};
var ArrayProperty = class extends PropertyGroup {
  formPropertyFactory;
  constructor(injector, formPropertyFactory, schemaValidatorFactory, schema, ui, formData, parent, path, options) {
    super(injector, schemaValidatorFactory, schema, ui, formData, parent, path, options);
    this.formPropertyFactory = formPropertyFactory;
    this.properties = [];
  }
  getProperty(path) {
    const subPathIdx = path.indexOf(SF_SEQ);
    const pos = +(subPathIdx !== -1 ? path.substring(0, subPathIdx) : path);
    const list = this.properties;
    if (isNaN(pos) || pos >= list.length) {
      return void 0;
    }
    const subPath = path.substring(subPathIdx + 1);
    return list[pos].getProperty(subPath);
  }
  setValue(value, onlySelf) {
    this.properties = [];
    this.clearErrors();
    this.resetProperties(value);
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    this._value = value || this.schema.default || [];
    this.setValue(this._value, onlySelf);
  }
  _hasValue() {
    return true;
  }
  _updateValue() {
    const value = [];
    this.forEachChild((property) => {
      if (property.visible) {
        value.push(__spreadValues(__spreadValues({}, this.widget?.cleanValue ? null : property.formData), property.value));
      }
    });
    this._value = value;
  }
  addProperty(formData) {
    const newProperty = this.formPropertyFactory.createProperty(deepCopy(this.schema.items), deepCopy(this.ui.$items), formData, this);
    this.properties.push(newProperty);
    return newProperty;
  }
  resetProperties(formDatas) {
    for (const item of formDatas) {
      const property = this.addProperty(item);
      property.resetValue(item, true);
    }
  }
  clearErrors(property) {
    (property || this)._objErrors = {};
  }
  // #region actions
  add(formData) {
    const newProperty = this.addProperty(formData);
    newProperty.resetValue(formData, false);
    return newProperty;
  }
  remove(index) {
    const list = this.properties;
    this.clearErrors();
    list.splice(index, 1);
    list.forEach((property, idx) => {
      property.path = [property.parent.path, idx].join(SF_SEQ);
      this.clearErrors(property);
      if (property instanceof ObjectProperty) {
        property.forEachChild((p) => {
          p.updateValueAndValidity({
            emitValueEvent: false
          });
        });
      }
    });
    if (list.length === 0) {
      this.updateValueAndValidity();
    }
  }
};
var AtomicProperty = class extends FormProperty {
  setValue(value, onlySelf) {
    this._value = value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
  resetValue(value, onlySelf) {
    if (value == null) {
      value = this.schema.default !== void 0 ? this.schema.default : this.fallbackValue();
    }
    this._value = value;
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
    if (this.widget) {
      this.widget.reset(value);
      this.cd(onlySelf);
    }
  }
  _hasValue() {
    return this.fallbackValue() !== this.value;
  }
  _updateValue() {
  }
};
var BooleanProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
};
var NumberProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
  setValue(value, onlySelf) {
    if (typeof value === "string") {
      if (value.length) {
        value = value.indexOf(".") > -1 ? parseFloat(value) : parseInt(value, 10);
      } else {
        value = void 0;
      }
    }
    this._value = value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
};
var StringProperty = class extends AtomicProperty {
  fallbackValue() {
    return null;
  }
  setValue(value, onlySelf) {
    this._value = value == null ? "" : value;
    this.cd(onlySelf);
    this.updateValueAndValidity({
      onlySelf,
      emitValueEvent: true
    });
  }
};
var FormPropertyFactory = class {
  injector;
  schemaValidatorFactory;
  options;
  constructor(injector, schemaValidatorFactory, cogSrv) {
    this.injector = injector;
    this.schemaValidatorFactory = schemaValidatorFactory;
    this.options = mergeConfig(cogSrv);
  }
  createProperty(schema, ui, formData, parent = null, propertyId) {
    let newProperty = null;
    let path = "";
    if (parent) {
      path += parent.path;
      if (parent.parent !== null) {
        path += SF_SEQ;
      }
      switch (parent.type) {
        case "object":
          path += propertyId;
          break;
        case "array":
          path += parent.properties.length;
          break;
        default:
          throw new Error(`Instanciation of a FormProperty with an unknown parent type: ${parent.type}`);
      }
    } else {
      path = SF_SEQ;
    }
    if (schema.$ref) {
      const refSchema = retrieveSchema(schema, parent.root.schema.definitions);
      newProperty = this.createProperty(refSchema, ui, formData, parent, path);
    } else {
      if (propertyId && parent.schema.required.indexOf(propertyId.split(SF_SEQ).pop()) !== -1 || ui.showRequired === true) {
        ui._required = true;
      }
      if (schema.title == null) {
        schema.title = propertyId;
      }
      if ((schema.type === "string" || schema.type === "number") && !schema.format && !ui.format) {
        if (ui.widget === "date") ui._format = schema.type === "string" ? this.options.uiDateStringFormat : this.options.uiDateNumberFormat;
        else if (ui.widget === "time") ui._format = schema.type === "string" ? this.options.uiTimeStringFormat : this.options.uiTimeNumberFormat;
      } else {
        ui._format = ui.format;
      }
      switch (schema.type) {
        case "integer":
        case "number":
          newProperty = new NumberProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "string":
          newProperty = new StringProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "boolean":
          newProperty = new BooleanProperty(this.injector, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "object":
          newProperty = new ObjectProperty(this.injector, this, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        case "array":
          newProperty = new ArrayProperty(this.injector, this, this.schemaValidatorFactory, schema, ui, formData, parent, path, this.options);
          break;
        default:
          throw new TypeError(`Undefined type ${schema.type}`);
      }
    }
    newProperty.propertyId = propertyId;
    if (newProperty instanceof PropertyGroup) {
      this.initializeRoot(newProperty);
    }
    return newProperty;
  }
  initializeRoot(rootProperty) {
    rootProperty._bindVisibility();
  }
};
var TerminatorService = class {
  onDestroy;
  constructor() {
    this.onDestroy = new Subject();
  }
  destroy() {
    this.onDestroy.next(true);
  }
};
var SchemaValidatorFactory = class _SchemaValidatorFactory {
  static ɵfac = function SchemaValidatorFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SchemaValidatorFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SchemaValidatorFactory,
    factory: _SchemaValidatorFactory.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchemaValidatorFactory, [{
    type: Injectable
  }], null, null);
})();
var AjvSchemaValidatorFactory = class _AjvSchemaValidatorFactory extends SchemaValidatorFactory {
  ngZone = inject(NgZone);
  cogSrv = inject(AlainConfigService);
  ajv;
  options;
  constructor() {
    super();
    if (!(typeof document === "object" && !!document)) {
      return;
    }
    this.options = mergeConfig(this.cogSrv);
    const customOptions = this.options.ajv || {};
    this.ngZone.runOutsideAngular(() => {
      this.ajv = new import_ajv.default(__spreadProps(__spreadValues({
        allErrors: true,
        loopEnum: 50
      }, customOptions), {
        formats: __spreadValues({
          "data-url": /^data:([a-z]+\/[a-z0-9-+.]+)?;name=(.*);base64,(.*)$/,
          color: REGEX.color,
          mobile: REGEX.mobile,
          "id-card": REGEX.idCard
        }, customOptions.formats)
      }));
      (0, import_ajv_formats.default)(this.ajv);
    });
  }
  createValidatorFn(schema, extraOptions) {
    const ingoreKeywords = [...this.options.ingoreKeywords, ...extraOptions.ingoreKeywords || []];
    return (value) => {
      try {
        this.ngZone.runOutsideAngular(() => this.ajv.validate(schema, value));
      } catch (e) {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (extraOptions.debug) {
            console.warn(e);
          }
        }
      }
      let errors = this.ajv.errors;
      if (this.options && ingoreKeywords && errors) {
        errors = errors.filter((w) => ingoreKeywords.indexOf(w.keyword) === -1);
      }
      return errors;
    };
  }
  static ɵfac = function AjvSchemaValidatorFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AjvSchemaValidatorFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AjvSchemaValidatorFactory,
    factory: _AjvSchemaValidatorFactory.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AjvSchemaValidatorFactory, [{
    type: Injectable
  }], () => [], null);
})();
var WidgetRegistry = class {
  _widgets = {};
  defaultWidget;
  get widgets() {
    return this._widgets;
  }
  setDefault(widget) {
    this.defaultWidget = widget;
  }
  register(type, widget) {
    this._widgets[type] = widget;
  }
  has(type) {
    return Object.prototype.hasOwnProperty.call(this._widgets, type);
  }
  getType(type) {
    if (this.has(type)) {
      return this._widgets[type];
    }
    return this.defaultWidget;
  }
};
var WidgetFactory = class _WidgetFactory {
  registry = inject(WidgetRegistry);
  createWidget(container, type) {
    if (!this.registry.has(type)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`No widget for type "${type}"`);
      }
    }
    const componentClass = this.registry.getType(type);
    return container.createComponent(componentClass);
  }
  static ɵfac = function WidgetFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _WidgetFactory)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _WidgetFactory,
    factory: _WidgetFactory.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WidgetFactory, [{
    type: Injectable
  }], null, null);
})();
var nextUniqueId = 0;
var SFItemComponent = class _SFItemComponent {
  widgetFactory = inject(WidgetFactory);
  terminator = inject(TerminatorService);
  ref;
  destroy$ = new Subject();
  widget = null;
  formProperty;
  footer = null;
  container;
  onWidgetInstanciated(widget) {
    this.widget = widget;
    const id = `_sf-${nextUniqueId++}`;
    const ui = this.formProperty.ui;
    this.widget.formProperty = this.formProperty;
    this.widget.schema = this.formProperty.schema;
    this.widget.ui = ui;
    this.widget.id = id;
    this.formProperty.widget = widget;
  }
  ngOnInit() {
    this.terminator.onDestroy.subscribe(() => this.ngOnDestroy());
  }
  ngOnChanges() {
    const p = this.formProperty;
    this.ref = this.widgetFactory.createWidget(this.container, p.ui.widget || p.schema.type);
    this.onWidgetInstanciated(this.ref.instance);
  }
  ngOnDestroy() {
    const {
      destroy$
    } = this;
    destroy$.next();
    destroy$.complete();
    this.ref.destroy();
  }
  static ɵfac = function SFItemComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SFItemComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SFItemComponent,
    selectors: [["sf-item"]],
    viewQuery: function SFItemComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c0, 7, ViewContainerRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function SFItemComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("sf__item", true);
      }
    },
    inputs: {
      formProperty: "formProperty",
      footer: "footer"
    },
    exportAs: ["sfItem"],
    standalone: false,
    features: [ɵɵProvidersFeature([NzFormStatusService]), ɵɵNgOnChangesFeature],
    decls: 3,
    vars: 1,
    consts: [["target", ""], [4, "ngTemplateOutlet"]],
    template: function SFItemComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, SFItemComponent_ng_template_0_Template, 0, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, SFItemComponent_ng_container_2_Template, 1, 0, "ng-container", 1);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngTemplateOutlet", ctx.footer);
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFItemComponent, [{
    type: Component,
    args: [{
      selector: "sf-item",
      exportAs: "sfItem",
      host: {
        "[class.sf__item]": "true"
      },
      template: `
    <ng-template #target />
    <ng-container *ngTemplateOutlet="footer" />
  `,
      encapsulation: ViewEncapsulation.None,
      providers: [NzFormStatusService],
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, {
    formProperty: [{
      type: Input
    }],
    footer: [{
      type: Input
    }],
    container: [{
      type: ViewChild,
      args: ["target", {
        read: ViewContainerRef,
        static: true
      }]
    }]
  });
})();
var SFFixedDirective = class _SFFixedDirective {
  el = inject(ElementRef).nativeElement;
  render = inject(Renderer2);
  _inited = false;
  num;
  init() {
    if (!this._inited || this.num == null || this.num <= 0) return;
    const el = this.el;
    const widgetEl = el.querySelector(".ant-row") || el;
    this.render.addClass(widgetEl, "sf__fixed");
    const labelEl = widgetEl.querySelector(".ant-form-item-label");
    const controlEl = widgetEl.querySelector(".ant-form-item-control-wrapper,.ant-form-item-control");
    const unit = `${this.num}px`;
    if (labelEl) {
      this.render.setStyle(labelEl, "flex", `0 0 ${unit}`);
      this.render.setStyle(controlEl, "max-width", `calc(100% - ${unit})`);
    } else {
      this.render.setStyle(controlEl, "margin-left", unit);
    }
  }
  ngAfterViewInit() {
    this._inited = true;
    this.init();
  }
  ngOnChanges() {
    if (this._inited) this.init();
  }
  static ɵfac = function SFFixedDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SFFixedDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SFFixedDirective,
    selectors: [["", "fixed-label", ""]],
    inputs: {
      num: [2, "fixed-label", "num", (v) => numberAttribute(v, 0)]
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFFixedDirective, [{
    type: Directive,
    args: [{
      selector: "[fixed-label]",
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, {
    num: [{
      type: Input,
      args: [{
        alias: "fixed-label",
        transform: (v) => numberAttribute(v, 0)
      }]
    }]
  });
})();
function useFactory(injector, schemaValidatorFactory, cogSrv) {
  return new FormPropertyFactory(injector, schemaValidatorFactory, cogSrv);
}
var SFComponent = class _SFComponent {
  formPropertyFactory = inject(FormPropertyFactory);
  terminator = inject(TerminatorService);
  dom = inject(DomSanitizer);
  cdr = inject(ChangeDetectorRef);
  localeSrv = inject(DelonLocaleService);
  aclSrv = inject(ACLService);
  i18nSrv = inject(ALAIN_I18N_TOKEN);
  platform = inject(Platform);
  cogSrv = inject(AlainConfigService);
  _renders = /* @__PURE__ */ new Map();
  _item;
  _valid = true;
  _defUi;
  options;
  _inited = false;
  locale = {};
  rootProperty = null;
  _formData;
  _btn;
  _schema;
  _ui;
  get btnGrid() {
    return this._btn.render.grid;
  }
  // #region fields
  /** 表单布局，等同 `nzLayout`，默认：horizontal */
  layout = "horizontal";
  /** JSON Schema */
  schema;
  /** UI Schema */
  ui;
  /** 表单默认值 */
  formData;
  /**
   * 按钮
   * - 值为 `null` 或 `undefined` 表示手动添加按钮，但保留容器
   * - 值为 `none` 表示手动添加按钮，且不保留容器
   * - 使用 `spanLabelFixed` 固定标签宽度时，若无 `render.class` 则默认为居中状态
   */
  button = {};
  /**
   * 是否实时校验，默认：`true`
   * - `true` 每一次都校验
   * - `false` 提交时校验
   */
  liveValidate = true;
  /** 指定表单 `autocomplete` 值 */
  autocomplete;
  /**
   * Whether to display error visuals immediately
   *
   * 是否立即显示错误视觉
   */
  firstVisual = true;
  /**
   * Whether to only display error visuals but not error text
   *
   * 是否只展示错误视觉不显示错误文本
   */
  onlyVisual = false;
  compact = false;
  /**
   * Form default mode, will force override `layout`, `firstVisual`, `liveValidate` parameters
   *
   * 表单预设模式，会强制覆盖 `layout`，`firstVisual`，`liveValidate` 参数
   */
  set mode(value) {
    switch (value) {
      case "search":
        this.layout = "inline";
        this.firstVisual = false;
        this.liveValidate = false;
        if (this._btn) {
          this._btn.submit = this._btn.search;
        }
        break;
      case "edit":
        this.layout = "horizontal";
        this.firstVisual = false;
        this.liveValidate = true;
        if (this._btn) {
          this._btn.submit = this._btn.edit;
        }
        break;
    }
    this._mode = value;
  }
  get mode() {
    return this._mode;
  }
  _mode;
  /**
   * Whether to load status，when `true` reset button is disabled status, submit button is loading status
   */
  loading = false;
  disabled = false;
  noColon = false;
  cleanValue = false;
  delay = false;
  formValueChange = new EventEmitter();
  formChange = new EventEmitter();
  formSubmit = new EventEmitter();
  formReset = new EventEmitter();
  formError = new EventEmitter();
  // #endregion
  /**
   * Whether the form is valid
   *
   * 表单是否有效
   */
  get valid() {
    return this._valid;
  }
  /**
   * The value of the form
   *
   * 表单值
   */
  get value() {
    return this._item;
  }
  /**
   * Get form element property based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)获取表单元素属性
   */
  getProperty(path) {
    return this.rootProperty?.searchProperty(path);
  }
  /**
   * Get element value based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)获取表单元素值
   */
  getValue(path) {
    return this.getProperty(path)?.value;
  }
  /**
   * Set form element new value based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)设置某个表单元素属性值
   */
  setValue(path, value) {
    const item = this.getProperty(path);
    if (!item) {
      throw new Error(`Invalid path: ${path}`);
    }
    item.resetValue(value, false);
    return this;
  }
  /**
   * Set form element new `disabled` based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)设置某个表单元素 `disabled` 状态
   */
  setDisabled(path, status) {
    const property = this.getProperty(path);
    if (!property) {
      throw new Error(`Invalid path: ${path}`);
    }
    property.schema.readOnly = status;
    property.widget.detectChanges();
    return this;
  }
  /**
   * Set form element new `required` based on [path](https://ng-alain.com/form/qa#path)
   *
   * 根据[路径](https://ng-alain.com/form/qa#path)设置某个表单元素 `required` 状态
   */
  setRequired(path, status) {
    const property = this.getProperty(path);
    if (!property) {
      throw new Error(`Invalid path: ${path}`);
    }
    const key = path.split(SF_SEQ).pop();
    const parentRequired = property.parent?.schema.required || [];
    const idx = parentRequired.findIndex((w) => w === key);
    if (status) {
      if (idx === -1) parentRequired.push(key);
    } else {
      if (idx !== -1) parentRequired.splice(idx, 1);
    }
    property.parent.schema.required = parentRequired;
    property.ui._required = status;
    property.widget.detectChanges();
    this.validator({
      onlyRoot: false
    });
    return this;
  }
  /**
   * Update the feedback status of the widget
   *
   * 更新小部件的反馈状态
   *
   * ```ts
   * // Validate status of the widget
   * this.sf.updateFeedback('/name', 'validating');
   * // Clean validate status of the widget
   * this.sf.updateFeedback('/name');
   * ```
   */
  updateFeedback(path, status = "") {
    this.getProperty(path)?.updateFeedback(status);
    return this;
  }
  onSubmit(e) {
    e.preventDefault();
    e.stopPropagation();
    if (!this.liveValidate) this.validator();
    if (!this.valid) return;
    this.formSubmit.emit(this.value);
  }
  constructor() {
    this.options = mergeConfig(this.cogSrv);
    this.liveValidate = this.options.liveValidate;
    this.firstVisual = this.options.firstVisual;
    this.autocomplete = this.options.autocomplete;
    this.delay = this.options.delay;
    this.localeSrv.change.pipe(takeUntilDestroyed()).subscribe(() => {
      this.locale = this.localeSrv.getData("sf");
      if (this._inited) {
        this.validator({
          emitError: false,
          onlyRoot: false
        });
        this.coverButtonProperty();
        this.cdr.markForCheck();
      }
    });
    merge(this.aclSrv.change, this.i18nSrv.change).pipe(filter(() => this._inited), takeUntilDestroyed()).subscribe(() => this.refreshSchema());
  }
  fanyi(key) {
    return this.i18nSrv.fanyi(key) || key;
  }
  inheritUI(ui) {
    ["optionalHelp"].filter((key) => !!this._defUi[key]).forEach((key) => ui[key] = __spreadValues(__spreadValues({}, this._defUi[key]), ui[key]));
  }
  coverProperty() {
    const isHorizontal = this.layout === "horizontal";
    const _schema = deepCopy(this.schema);
    const {
      definitions
    } = _schema;
    const inFn = (schema, _parentSchema, uiSchema, parentUiSchema, uiRes) => {
      if (!Array.isArray(schema.required)) schema.required = [];
      Object.keys(schema.properties).forEach((key) => {
        const uiKeyPrefix = "$";
        const uiKey = uiKeyPrefix + key;
        const property = retrieveSchema(schema.properties[key], definitions);
        const curUi = __spreadValues(__spreadValues({}, property.ui), uiSchema[uiKey]);
        const ui = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadProps(__spreadValues(__spreadValues({}, this._defUi), parentUiSchema), {
          // 忽略部分会引起呈现的属性
          visibleIf: void 0,
          hidden: void 0,
          optional: void 0,
          optionalHelp: void 0,
          widget: property.type
        }), property.format && this.options.formatMap[property.format]), typeof property.ui === "string" ? {
          widget: property.ui
        } : null), !property.format && !property.ui && Array.isArray(property.enum) && property.enum.length > 0 ? {
          widget: "select"
        } : null), curUi);
        Object.keys(ui).filter((key2) => key2.startsWith(uiKeyPrefix)).forEach((key2) => delete ui[key2]);
        if (isHorizontal) {
          if (parentUiSchema.spanLabelFixed) {
            if (!curUi.spanLabelFixed) {
              ui.spanLabelFixed = parentUiSchema.spanLabelFixed;
            }
          } else {
            if (!ui.spanLabel) ui.spanLabel = typeof parentUiSchema.spanLabel === "undefined" ? 5 : parentUiSchema.spanLabel;
            if (!ui.spanControl) ui.spanControl = typeof parentUiSchema.spanControl === "undefined" ? 19 : parentUiSchema.spanControl;
            if (!ui.offsetControl) ui.offsetControl = typeof parentUiSchema.offsetControl === "undefined" ? null : parentUiSchema.offsetControl;
          }
        } else {
          ui.spanLabel = null;
          ui.spanControl = null;
          ui.offsetControl = null;
        }
        if (this.layout === "inline") {
          delete ui.grid;
        }
        if (this.layout !== "horizontal") {
          ui.spanLabelFixed = null;
        }
        if (ui.spanLabelFixed != null && ui.spanLabelFixed > 0) {
          ui.spanLabel = null;
          ui.spanControl = null;
        }
        if (ui.widget === "date" && ui.end != null) {
          const dateEndProperty = schema.properties[ui.end];
          if (dateEndProperty) {
            dateEndProperty.ui = __spreadProps(__spreadValues({}, dateEndProperty.ui), {
              widget: ui.widget,
              hidden: true
            });
          } else {
            ui.end = null;
          }
        }
        this.inheritUI(ui);
        if (ui.optionalHelp) {
          if (typeof ui.optionalHelp === "string") {
            ui.optionalHelp = {
              text: ui.optionalHelp
            };
          }
          const oh = ui.optionalHelp = __spreadValues({
            text: "",
            icon: "question-circle",
            placement: "top",
            trigger: "hover",
            mouseEnterDelay: 0.15,
            mouseLeaveDelay: 0.1
          }, ui.optionalHelp);
          if (oh.i18n) {
            oh.text = this.fanyi(oh.i18n);
          }
          if (!oh.text) {
            ui.optionalHelp = void 0;
          }
        }
        if (ui.i18n) {
          property.title = this.fanyi(ui.i18n);
        }
        if (ui.descriptionI18n) {
          property.description = this.fanyi(ui.descriptionI18n);
        }
        if (property.description) {
          ui._description = this.dom.bypassSecurityTrustHtml(property.description);
        }
        ui.hidden = typeof ui.hidden === "boolean" ? ui.hidden : false;
        if (ui.hidden === false && ui.acl && this.aclSrv && !this.aclSrv.can(ui.acl)) {
          ui.hidden = true;
        }
        uiRes[uiKey] = ui;
        delete property.ui;
        if (ui.hidden === true) {
          const idx = schema.required.indexOf(key);
          if (idx !== -1) {
            schema.required.splice(idx, 1);
          }
        }
        if (property.items) {
          ui.$items = __spreadValues(__spreadValues(__spreadValues({}, property.items.ui), uiSchema[uiKey]), ui.$items);
          inFn(property.items, property.items, uiSchema[uiKey]?.$items ?? {}, ui.$items, ui.$items);
          delete property.items.ui;
        }
        if (property.properties && Object.keys(property.properties).length) {
          inFn(property, schema, uiSchema[uiKey] || {}, ui, ui);
        }
      });
    };
    if (this.ui == null) this.ui = {};
    this._defUi = __spreadValues(__spreadValues(__spreadValues({
      onlyVisual: this.options.onlyVisual,
      size: this.options.size,
      liveValidate: this.liveValidate
    }, this.options.ui), _schema.ui), this.ui["*"]);
    if (this.onlyVisual === true) {
      this._defUi.onlyVisual = true;
    }
    if (this.layout === "inline") {
      delete this._defUi.grid;
    }
    this._ui = __spreadValues({}, this._defUi);
    inFn(_schema, _schema, this.ui, this.ui, this._ui);
    resolveIfSchema(_schema, this._ui);
    this._schema = _schema;
    delete _schema.ui;
    di(this._ui, "cover schema & ui", this._ui, _schema);
  }
  coverButtonProperty() {
    this._btn = __spreadValues(__spreadValues(__spreadValues({
      render: {
        size: "default"
      }
    }, this.locale), this.options.button), this.button);
    const firstKey = Object.keys(this._ui).find((w) => w.startsWith("$"));
    const btnRender = this._btn.render;
    if (this.layout === "horizontal") {
      const btnUi = firstKey ? this._ui[firstKey] : this._defUi;
      if (!btnRender.grid) {
        btnRender.grid = {
          offset: btnUi.spanLabel,
          span: btnUi.spanControl
        };
      }
      if (btnRender.spanLabelFixed == null) {
        btnRender.spanLabelFixed = btnUi.spanLabelFixed;
      }
      if (!btnRender.class && typeof btnUi.spanLabelFixed === "number" && btnUi.spanLabelFixed > 0) {
        btnRender.class = "text-center";
      }
    } else {
      btnRender.grid = {};
    }
    if (this._mode) {
      this.mode = this._mode;
    }
    di(this._ui, "button property", this._btn);
  }
  ngOnInit() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.validator();
    this._inited = true;
  }
  ngOnChanges(changes) {
    if (!this.platform.isBrowser) {
      return;
    }
    const ingoreRender = ["disabled", "loading"];
    if (Object.keys(changes).every((key) => ingoreRender.includes(key))) {
      this.cdr.detectChanges();
      return;
    }
    if (!this.delay) {
      this.refreshSchema();
    }
  }
  /** @internal */
  _addTpl(path, templateRef) {
    if (!this._inited) {
      return;
    }
    if (this._renders.has(path)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        console.warn(`Duplicate definition "${path}" custom widget`);
      }
      return;
    }
    this._renders.set(path, templateRef);
    this.attachCustomRender();
  }
  attachCustomRender() {
    this._renders.forEach((tpl, path) => {
      const property = this.rootProperty?.searchProperty(path);
      if (property == null) {
        return;
      }
      property.ui._render = tpl;
    });
  }
  /**
   * Validator the form is valid
   *
   * 校验表单是否有效
   * - `emitError` 当表单无效时是否触发 `formError` 事件，默认：`true`
   * - `onlyRoot` 只对根进行检验，不进行向下逐个递归，根已经包含整个 Json Schema，默认：`true`
   */
  validator(options = {
    emitError: true,
    onlyRoot: true
  }) {
    if (this.rootProperty == null || !this.platform.isBrowser) {
      return false;
    }
    const fn = (property) => {
      property._runValidation();
      if (!(property instanceof PropertyGroup) || !property.properties) return;
      if (Array.isArray(property.properties)) {
        property.properties.forEach((p) => fn(p));
      } else {
        Object.keys(property.properties).forEach((key) => fn(property.properties[key]));
      }
    };
    if (options.onlyRoot) {
      this.rootProperty._runValidation();
    } else {
      fn(this.rootProperty);
    }
    const errors = this.rootProperty.errors;
    this._valid = !(errors && errors.length);
    if (options.emitError && !this._valid) this.formError.emit(errors);
    this.cdr.detectChanges();
    return this._valid;
  }
  /**
   * Refresh the form Schema, when specifying `newSchema` means to replace the current Schema
   *
   * 刷新 Schema，当指定 `newSchema` 表示替换当前的 Schema
   *
   * 可以针对某个表单元素进行刷新，例如：
   * ```
   * // 获取某个元素
   * const statusProperty = this.sf.getProperty('/status')!;
   * // 重置 `schema` 或 `ui` 参数
   * statusProperty.schema.enum = ['1', '2', '3'];
   * // 调用 `reset` 重置初始值
   * statusProperty.widget.reset('2');
   * ```
   */
  refreshSchema(newSchema, newUI) {
    if (!this.platform.isBrowser) {
      return this;
    }
    if (newSchema) this.schema = newSchema;
    if (newUI) this.ui = newUI;
    if (!this.schema || typeof this.schema.properties === "undefined") throw new Error(`Invalid Schema`);
    if (this.schema.ui && typeof this.schema.ui === "string") throw new Error(`Don't support string with root ui property`);
    this.schema.type = "object";
    this._formData = __spreadValues({}, this.formData);
    if (this._inited) this.terminator.destroy();
    this.cleanRootSub();
    this.coverProperty();
    this.coverButtonProperty();
    this.rootProperty = this.formPropertyFactory.createProperty(this._schema, this._ui, this.formData);
    this.attachCustomRender();
    this.cdr.detectChanges();
    this.reset();
    let isFirst = true;
    this.rootProperty.valueChanges.subscribe((res) => {
      this._item = __spreadValues(__spreadValues({}, this.cleanValue ? null : this.formData), res.value);
      if (isFirst) {
        isFirst = false;
        return;
      }
      this.formChange.emit(this._item);
      this.formValueChange.emit({
        value: this._item,
        path: res.path,
        pathValue: res.pathValue
      });
    });
    this.rootProperty.errorsChanges.subscribe((errors) => {
      this._valid = !(errors && errors.length);
      this.formError.emit(errors);
      this.cdr.detectChanges();
    });
    return this;
  }
  /**
   * Reset form
   *
   * 重置表单
   *
   * @param [emit] 是否触发 `formReset` 事件，默认：`false`
   */
  reset(emit = false) {
    if (this.rootProperty == null || !this.platform.isBrowser) {
      return this;
    }
    this.rootProperty.resetValue(this.formData, false);
    Promise.resolve().then(() => this.cdr.detectChanges());
    if (emit) {
      this.formReset.emit(this.value);
    }
    return this;
  }
  cleanRootSub() {
    if (!this.rootProperty) return;
    this.rootProperty.errorsChanges.unsubscribe();
    this.rootProperty.valueChanges.unsubscribe();
  }
  ngOnDestroy() {
    this.cleanRootSub();
    this.terminator.destroy();
  }
  static ɵfac = function SFComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SFComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SFComponent,
    selectors: [["sf"], ["", "sf", ""]],
    hostVars: 16,
    hostBindings: function SFComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("sf", true)("sf__inline", ctx.layout === "inline")("sf__horizontal", ctx.layout === "horizontal")("sf__search", ctx.mode === "search")("sf__edit", ctx.mode === "edit")("sf__no-error", ctx.onlyVisual)("sf__no-colon", ctx.noColon)("sf__compact", ctx.compact);
      }
    },
    inputs: {
      layout: "layout",
      schema: "schema",
      ui: "ui",
      formData: "formData",
      button: "button",
      liveValidate: [2, "liveValidate", "liveValidate", booleanAttribute],
      autocomplete: "autocomplete",
      firstVisual: [2, "firstVisual", "firstVisual", booleanAttribute],
      onlyVisual: [2, "onlyVisual", "onlyVisual", booleanAttribute],
      compact: [2, "compact", "compact", booleanAttribute],
      mode: "mode",
      loading: [2, "loading", "loading", booleanAttribute],
      disabled: [2, "disabled", "disabled", booleanAttribute],
      noColon: [2, "noColon", "noColon", booleanAttribute],
      cleanValue: [2, "cleanValue", "cleanValue", booleanAttribute],
      delay: [2, "delay", "delay", booleanAttribute]
    },
    outputs: {
      formValueChange: "formValueChange",
      formChange: "formChange",
      formSubmit: "formSubmit",
      formReset: "formReset",
      formError: "formError"
    },
    exportAs: ["sf"],
    standalone: false,
    features: [ɵɵProvidersFeature([WidgetFactory, {
      provide: FormPropertyFactory,
      useFactory,
      deps: [Injector, SchemaValidatorFactory, AlainConfigService]
    }, TerminatorService]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c1,
    decls: 6,
    vars: 3,
    consts: [["con", ""], ["btnTpl", ""], ["nz-form", "", 3, "submit", "nzLayout"], [3, "formProperty", "footer"], [3, "ngTemplateOutlet"], [1, "sf-btns", 3, "class", "fixed-label"], [1, "sf-btns", 3, "fixed-label"], ["nz-col", "", 1, "ant-form-item-control", 3, "nzSpan", "nzOffset", "nzXs", "nzSm", "nzMd", "nzLg", "nzXl", "nzXXl"], [1, "ant-form-item-control-input"], [1, "ant-form-item-control-input-content"], ["type", "submit", "nz-button", "", "data-type", "submit", 3, "nzType", "nzSize", "nzLoading", "disabled"], [3, "nzType", "nzTheme", "nzTwotoneColor", "nzIconfont"], ["type", "button", "nz-button", "", "data-type", "reset", 3, "nzType", "nzSize", "disabled"], ["type", "button", "nz-button", "", "data-type", "reset", 3, "click", "nzType", "nzSize", "disabled"]],
    template: function SFComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵtemplate(0, SFComponent_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, SFComponent_ng_template_2_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementStart(4, "form", 2);
        ɵɵlistener("submit", function SFComponent_Template_form_submit_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onSubmit($event));
        });
        ɵɵconditionalCreate(5, SFComponent_Conditional_5_Template, 1, 2, "sf-item", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(4);
        ɵɵproperty("nzLayout", ctx.layout);
        ɵɵattribute("autocomplete", ctx.autocomplete);
        ɵɵadvance();
        ɵɵconditional(ctx.rootProperty ? 5 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, ɵNgNoValidate, NgControlStatusGroup, NgForm, NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzColDirective, NzRowDirective, NzFormDirective, NzFormItemComponent, NzIconDirective, SFItemComponent, SFFixedDirective],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFComponent, [{
    type: Component,
    args: [{
      selector: "sf, [sf]",
      exportAs: "sf",
      providers: [WidgetFactory, {
        provide: FormPropertyFactory,
        useFactory,
        deps: [Injector, SchemaValidatorFactory, AlainConfigService]
      }, TerminatorService],
      host: {
        "[class.sf]": "true",
        "[class.sf__inline]": `layout === 'inline'`,
        "[class.sf__horizontal]": `layout === 'horizontal'`,
        "[class.sf__search]": `mode === 'search'`,
        "[class.sf__edit]": `mode === 'edit'`,
        "[class.sf__no-error]": `onlyVisual`,
        "[class.sf__no-colon]": `noColon`,
        "[class.sf__compact]": `compact`
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      standalone: false,
      template: `<ng-template #con>
  <ng-content />
</ng-template>
<ng-template #btnTpl>
  @if (button !== 'none') {
    @let btnRender = _btn.render;
    @if (btnRender) {
      <nz-form-item [class]="btnRender.class!" class="sf-btns" [fixed-label]="btnRender.spanLabelFixed!">
        <div
          nz-col
          class="ant-form-item-control"
          [nzSpan]="btnGrid.span"
          [nzOffset]="btnGrid.offset"
          [nzXs]="btnGrid.xs"
          [nzSm]="btnGrid.sm"
          [nzMd]="btnGrid.md"
          [nzLg]="btnGrid.lg"
          [nzXl]="btnGrid.xl"
          [nzXXl]="btnGrid.xxl"
        >
          <div class="ant-form-item-control-input">
            <div class="ant-form-item-control-input-content">
              @if (button) {
                <button
                  type="submit"
                  nz-button
                  data-type="submit"
                  [nzType]="_btn.submit_type!"
                  [nzSize]="btnRender.size!"
                  [nzLoading]="loading"
                  [disabled]="liveValidate && !valid"
                >
                  @if (_btn.submit_icon) {
                    <nz-icon
                      [nzType]="_btn.submit_icon.type!"
                      [nzTheme]="_btn.submit_icon.theme!"
                      [nzTwotoneColor]="_btn.submit_icon.twoToneColor!"
                      [nzIconfont]="_btn.submit_icon.iconfont!"
                    />
                  }
                  {{ _btn.submit }}
                </button>
                @if (_btn.reset) {
                  <button
                    type="button"
                    nz-button
                    data-type="reset"
                    [nzType]="_btn.reset_type!"
                    [nzSize]="btnRender.size!"
                    [disabled]="loading"
                    (click)="reset(true)"
                  >
                    @let resetIcon = _btn.reset_icon;
                    @if (resetIcon) {
                      <nz-icon
                        [nzType]="resetIcon.type!"
                        [nzTheme]="resetIcon.theme!"
                        [nzTwotoneColor]="resetIcon.twoToneColor!"
                        [nzIconfont]="resetIcon.iconfont!"
                      />
                    }
                    {{ _btn.reset }}
                  </button>
                }
              } @else {
                <ng-template [ngTemplateOutlet]="con" />
              }
            </div>
          </div>
        </div>
      </nz-form-item>
    }
  } @else {
    <ng-template [ngTemplateOutlet]="con" />
  }
</ng-template>
<form nz-form [nzLayout]="layout" (submit)="onSubmit($event)" [attr.autocomplete]="autocomplete">
  @if (rootProperty) {
    <sf-item [formProperty]="rootProperty" [footer]="btnTpl" />
  }
</form>
`
    }]
  }], () => [], {
    layout: [{
      type: Input
    }],
    schema: [{
      type: Input
    }],
    ui: [{
      type: Input
    }],
    formData: [{
      type: Input
    }],
    button: [{
      type: Input
    }],
    liveValidate: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    autocomplete: [{
      type: Input
    }],
    firstVisual: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    onlyVisual: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    compact: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    mode: [{
      type: Input
    }],
    loading: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    noColon: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    cleanValue: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    delay: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    formValueChange: [{
      type: Output
    }],
    formChange: [{
      type: Output
    }],
    formSubmit: [{
      type: Output
    }],
    formReset: [{
      type: Output
    }],
    formError: [{
      type: Output
    }]
  });
})();
var SFItemWrapComponent = class _SFItemWrapComponent {
  statusSrv = inject(NzFormStatusService);
  _showTitle = false;
  id;
  schema;
  ui;
  showError;
  error;
  set showTitle(val) {
    this._showTitle = !!val;
  }
  title = null;
  get t() {
    return this.title === null ? this.schema.title : this.title;
  }
  get oh() {
    return this.ui.optionalHelp;
  }
  ngOnChanges() {
    const hasError = !!this.error;
    this.statusSrv.formStatusChanges.next({
      status: hasError ? "error" : "",
      hasFeedback: !!this.ui.feedback
    });
  }
  static ɵfac = function SFItemWrapComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SFItemWrapComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SFItemWrapComponent,
    selectors: [["sf-item-wrap"]],
    inputs: {
      id: "id",
      schema: "schema",
      ui: "ui",
      showError: "showError",
      error: "error",
      showTitle: "showTitle",
      title: "title"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    ngContentSelectors: _c1,
    decls: 8,
    vars: 21,
    consts: [["nz-col", "", 1, "ant-form-item-label", 3, "nzSpan"], ["nz-col", "", 1, "ant-form-item-control", 3, "nzSpan", "nzOffset"], [1, "ant-form-item-control-input"], [1, "ant-form-item-control-input-content"], [1, "ant-form-item-explain", "ant-form-item-explain-connected"], [1, "ant-form-item-extra", 3, "innerHTML"], [3, "ant-form-item-required"], [1, "sf__label-text"], [1, "sf__optional"], ["nz-tooltip", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipColor", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], ["role", "alert", 1, "ant-form-item-explain-error"]],
    template: function SFItemWrapComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "nz-form-item");
        ɵɵconditionalCreate(1, SFItemWrapComponent_Conditional_1_Template, 2, 2, "div", 0);
        ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
        ɵɵprojection(5);
        ɵɵelementEnd()();
        ɵɵconditionalCreate(6, SFItemWrapComponent_Conditional_6_Template, 3, 2, "div", 4);
        ɵɵconditionalCreate(7, SFItemWrapComponent_Conditional_7_Template, 1, 1, "div", 5);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵstyleProp("width", ctx.ui.width, "px");
        ɵɵclassProp("ant-form-item-has-error", ctx.showError)("ant-form-item-with-help", ctx.showError)("ant-form-item-has-success", ctx.ui.feedback === "success")("ant-form-item-has-warning", ctx.ui.feedback === "warning")("ant-form-item-has-error", ctx.ui.feedback === "error")("ant-form-item-is-validating", ctx.ui.feedback === "validating")("ant-form-item-has-feedback", ctx.ui.feedback);
        ɵɵadvance();
        ɵɵconditional(ctx._showTitle ? 1 : -1);
        ɵɵadvance();
        ɵɵproperty("nzSpan", ctx.ui.spanControl)("nzOffset", ctx.ui.offsetControl);
        ɵɵadvance(4);
        ɵɵconditional(!ctx.ui.onlyVisual && ctx.showError ? 6 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.schema.description ? 7 : -1);
      }
    },
    dependencies: [NzTransitionPatchDirective, NzColDirective, NzRowDirective, NzFormItemComponent, NzIconDirective, NzTooltipDirective],
    encapsulation: 2,
    data: {
      animation: [helpMotion]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFItemWrapComponent, [{
    type: Component,
    args: [{
      selector: "sf-item-wrap",
      animations: [helpMotion],
      encapsulation: ViewEncapsulation.None,
      standalone: false,
      template: `<nz-form-item
  [style.width.px]="ui.width"
  [class.ant-form-item-has-error]="showError"
  [class.ant-form-item-with-help]="showError"
  [class.ant-form-item-has-success]="ui.feedback === 'success'"
  [class.ant-form-item-has-warning]="ui.feedback === 'warning'"
  [class.ant-form-item-has-error]="ui.feedback === 'error'"
  [class.ant-form-item-is-validating]="ui.feedback === 'validating'"
  [class.ant-form-item-has-feedback]="ui.feedback"
>
  @if (_showTitle) {
    <div nz-col [nzSpan]="ui.spanLabel!" class="ant-form-item-label">
      @if (t) {
        <label [attr.for]="id" [class.ant-form-item-required]="ui._required">
          <span class="sf__label-text">{{ t }}</span>
          @if (ui.optional || oh) {
            <span class="sf__optional">
              {{ ui.optional }}
              @if (oh) {
                <nz-icon
                  nz-tooltip
                  [nzTooltipTitle]="oh.text"
                  [nzTooltipPlacement]="oh.placement"
                  [nzTooltipTrigger]="oh.trigger"
                  [nzTooltipColor]="oh.bgColor"
                  [nzTooltipOverlayClassName]="oh.overlayClassName"
                  [nzTooltipOverlayStyle]="oh.overlayStyle"
                  [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                  [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                  [nzType]="oh.icon!"
                />
              }
            </span>
          }
        </label>
      }
    </div>
  }
  <div nz-col class="ant-form-item-control" [nzSpan]="ui.spanControl!" [nzOffset]="ui.offsetControl!">
    <div class="ant-form-item-control-input">
      <div class="ant-form-item-control-input-content">
        <ng-content />
      </div>
    </div>
    @if (!ui.onlyVisual && showError) {
      <div @helpMotion class="ant-form-item-explain ant-form-item-explain-connected">
        <div role="alert" class="ant-form-item-explain-error">
          {{ error }}
        </div>
      </div>
    }
    @if (schema.description) {
      <div class="ant-form-item-extra" [innerHTML]="ui._description"></div>
    }
  </div>
</nz-form-item>
`
    }]
  }], null, {
    id: [{
      type: Input
    }],
    schema: [{
      type: Input
    }],
    ui: [{
      type: Input
    }],
    showError: [{
      type: Input
    }],
    error: [{
      type: Input
    }],
    showTitle: [{
      type: Input
    }],
    title: [{
      type: Input
    }]
  });
})();
var SFTemplateDirective = class _SFTemplateDirective {
  table = inject(SFComponent);
  templateRef = inject(TemplateRef);
  path;
  ngOnInit() {
    this.table._addTpl(this.path.startsWith(SF_SEQ) ? this.path : SF_SEQ + this.path, this.templateRef);
  }
  static ɵfac = function SFTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SFTemplateDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SFTemplateDirective,
    selectors: [["", "sf-template", ""]],
    inputs: {
      path: [0, "sf-template", "path"]
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SFTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[sf-template]",
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, {
    path: [{
      type: Input,
      args: ["sf-template"]
    }]
  });
})();
var Widget = class _Widget {
  cd = inject(ChangeDetectorRef);
  injector = inject(Injector);
  sfItemComp = inject(SFItemComponent);
  sfComp = inject(SFComponent);
  formProperty;
  error;
  showError = false;
  id = "";
  schema;
  ui;
  get cls() {
    return this.ui.class || "";
  }
  get disabled() {
    if (this.schema.readOnly === true || this.sfComp.disabled) {
      return true;
    }
    return false;
  }
  get l() {
    return this.formProperty.root.widget.sfComp.locale;
  }
  get oh() {
    return this.ui.optionalHelp;
  }
  get dom() {
    return this.injector.get(DomSanitizer);
  }
  get cleanValue() {
    return this.sfComp.cleanValue;
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe((errors) => {
      if (errors == null) return;
      di(this.ui, "errorsChanges", this.formProperty.path, errors);
      const firstVisual = this.sfComp?.firstVisual;
      if (firstVisual || !firstVisual && this.sfComp?._inited) {
        this.showError = errors.length > 0;
        this.error = this.showError ? errors[0].message : "";
        this.cd.detectChanges();
      }
    });
    this.afterViewInit();
  }
  setValue(value) {
    this.formProperty.setValue(value, false);
    di(this.ui, "valueChanges", this.formProperty.path, this.formProperty);
  }
  get value() {
    return this.formProperty.value;
  }
  detectChanges(onlySelf = false) {
    if (onlySelf) {
      this.cd.markForCheck();
    } else {
      this.formProperty.root.widget?.cd.markForCheck();
    }
  }
  static ɵfac = function Widget_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Widget)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _Widget,
    hostVars: 2,
    hostBindings: function Widget_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassMap(ctx.cls);
      }
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Widget, [{
    type: Directive
  }], null, {
    cls: [{
      type: HostBinding,
      args: ["class"]
    }]
  });
})();
var ControlWidget = class _ControlWidget extends Widget {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  reset(_value) {
  }
  afterViewInit() {
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵControlWidget_BaseFactory;
    return function ControlWidget_Factory(__ngFactoryType__) {
      return (ɵControlWidget_BaseFactory || (ɵControlWidget_BaseFactory = ɵɵgetInheritedFactory(_ControlWidget)))(__ngFactoryType__ || _ControlWidget);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _ControlWidget,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlWidget, [{
    type: Directive
  }], null, null);
})();
var ControlUIWidget = class _ControlUIWidget extends Widget {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  reset(_value) {
  }
  afterViewInit() {
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵControlUIWidget_BaseFactory;
    return function ControlUIWidget_Factory(__ngFactoryType__) {
      return (ɵControlUIWidget_BaseFactory || (ɵControlUIWidget_BaseFactory = ɵɵgetInheritedFactory(_ControlUIWidget)))(__ngFactoryType__ || _ControlUIWidget);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _ControlUIWidget,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlUIWidget, [{
    type: Directive
  }], null, null);
})();
var ArrayLayoutWidget = class _ArrayLayoutWidget extends Widget {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  reset(_value) {
  }
  afterViewInit() {
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵArrayLayoutWidget_BaseFactory;
    return function ArrayLayoutWidget_Factory(__ngFactoryType__) {
      return (ɵArrayLayoutWidget_BaseFactory || (ɵArrayLayoutWidget_BaseFactory = ɵɵgetInheritedFactory(_ArrayLayoutWidget)))(__ngFactoryType__ || _ArrayLayoutWidget);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _ArrayLayoutWidget,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayLayoutWidget, [{
    type: Directive
  }], null, null);
})();
var ObjectLayoutWidget = class _ObjectLayoutWidget extends Widget {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  reset(_value) {
  }
  afterViewInit() {
  }
  ngAfterViewInit() {
    this.formProperty.errorsChanges.pipe(takeUntil(this.sfItemComp.destroy$)).subscribe(() => this.cd.detectChanges());
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵObjectLayoutWidget_BaseFactory;
    return function ObjectLayoutWidget_Factory(__ngFactoryType__) {
      return (ɵObjectLayoutWidget_BaseFactory || (ɵObjectLayoutWidget_BaseFactory = ɵɵgetInheritedFactory(_ObjectLayoutWidget)))(__ngFactoryType__ || _ObjectLayoutWidget);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _ObjectLayoutWidget,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObjectLayoutWidget, [{
    type: Directive
  }], null, null);
})();
var ArrayWidget = class _ArrayWidget extends ArrayLayoutWidget {
  addTitle;
  addType;
  removeTitle;
  arraySpan = 8;
  get addDisabled() {
    return this.disabled || this.schema.maxItems != null && this.formProperty.properties.length >= this.schema.maxItems;
  }
  get showRemove() {
    if (this.disabled || !this.removeTitle) return false;
    if (this.schema.minItems != null && this.formProperty.properties.length <= this.schema.minItems) return false;
    return true;
  }
  ngOnInit() {
    const {
      grid,
      addTitle,
      addType,
      removable,
      removeTitle
    } = this.ui;
    if (grid && grid.arraySpan) {
      this.arraySpan = grid.arraySpan;
    }
    this.addTitle = this.dom.bypassSecurityTrustHtml(addTitle || this.l.addText);
    this.addType = addType || "dashed";
    this.removeTitle = removable === false ? null : removeTitle || this.l.removeText;
  }
  reValid(options) {
    this.formProperty.updateValueAndValidity(__spreadValues({
      onlySelf: false,
      emitValueEvent: false,
      emitValidator: true
    }, options));
  }
  addItem() {
    const property = this.formProperty.add({});
    this.reValid();
    this.ui.add?.(property);
  }
  removeItem(index) {
    const updatePath = this.formProperty.properties[index].path;
    this.formProperty.remove(index);
    this.reValid({
      updatePath,
      emitValueEvent: true
    });
    this.ui.remove?.(index);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵArrayWidget_BaseFactory;
    return function ArrayWidget_Factory(__ngFactoryType__) {
      return (ɵArrayWidget_BaseFactory || (ɵArrayWidget_BaseFactory = ɵɵgetInheritedFactory(_ArrayWidget)))(__ngFactoryType__ || _ArrayWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _ArrayWidget,
    selectors: [["sf-array"]],
    hostVars: 2,
    hostBindings: function ArrayWidget_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("sf__array", true);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 9,
    vars: 9,
    consts: [["nz-col", "", 1, "ant-form-item-label", 3, "nzSpan"], ["nz-col", "", 1, "ant-form-item-control-wrapper", 3, "nzSpan", "nzOffset"], [1, "ant-form-item-control"], ["nz-row", "", 1, "sf__array-container"], [1, "ant-form-explain"], [1, "ant-form-extra", 3, "innerHTML"], [1, "sf__optional"], ["nz-tooltip", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [1, "sf__array-add"], ["type", "button", "nz-button", "", 3, "click", "nzType", "disabled", "innerHTML"], ["nz-col", "", 1, "sf__array-item", 3, "nzSpan"], [3, "formProperty"], [1, "sf__array-remove"], [1, "sf__array-remove", 3, "click"], ["nzType", "delete"]],
    template: function ArrayWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "nz-form-item");
        ɵɵconditionalCreate(1, ArrayWidget_Conditional_1_Template, 8, 9, "div", 0);
        ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
        ɵɵrepeaterCreate(5, ArrayWidget_For_6_Template, 1, 1, null, null, ɵɵrepeaterTrackByIdentity);
        ɵɵelementEnd();
        ɵɵconditionalCreate(7, ArrayWidget_Conditional_7_Template, 2, 1, "div", 4);
        ɵɵconditionalCreate(8, ArrayWidget_Conditional_8_Template, 1, 1, "div", 5);
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵclassProp("ant-form-item-with-help", ctx.showError);
        ɵɵadvance();
        ɵɵconditional(ctx.schema.title ? 1 : -1);
        ɵɵadvance();
        ɵɵproperty("nzSpan", ctx.ui.spanControl)("nzOffset", ctx.ui.offsetControl);
        ɵɵadvance();
        ɵɵclassProp("has-error", ctx.showError);
        ɵɵadvance(2);
        ɵɵrepeater(ctx.formProperty.properties);
        ɵɵadvance(2);
        ɵɵconditional(!ctx.ui.onlyVisual && ctx.showError ? 7 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.schema.description ? 8 : -1);
      }
    },
    dependencies: [NzButtonComponent, NzTransitionPatchDirective, NzWaveDirective, NzCardComponent, NzColDirective, NzRowDirective, NzFormItemComponent, NzIconDirective, NzTooltipDirective, SFItemComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ArrayWidget, [{
    type: Component,
    args: [{
      selector: "sf-array",
      template: `<nz-form-item [class.ant-form-item-with-help]="showError">
    @if (schema.title) {
      <div nz-col [nzSpan]="ui.spanLabel!" class="ant-form-item-label">
        <label [class.ant-form-item-required]="ui.required">
          {{ schema.title }}
          <span class="sf__optional">
            {{ ui.optional }}
            @if (oh) {
              <nz-icon
                nz-tooltip
                [nzTooltipTitle]="oh.text"
                [nzTooltipPlacement]="oh.placement"
                [nzTooltipTrigger]="oh.trigger"
                [nzTooltipOverlayClassName]="oh.overlayClassName"
                [nzTooltipOverlayStyle]="oh.overlayStyle"
                [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                [nzType]="oh.icon!"
              />
            }
          </span>
        </label>
        <div class="sf__array-add">
          <button
            type="button"
            nz-button
            [nzType]="addType"
            [disabled]="addDisabled"
            (click)="addItem()"
            [innerHTML]="addTitle"
          ></button>
        </div>
      </div>
    }
    <div nz-col class="ant-form-item-control-wrapper" [nzSpan]="ui.spanControl!" [nzOffset]="ui.offsetControl!">
      <div class="ant-form-item-control" [class.has-error]="showError">
        <div nz-row class="sf__array-container">
          @for (i of $any(formProperty).properties; track i) {
            @if (i.visible && !i.ui.hidden) {
              <div nz-col [nzSpan]="arraySpan" [attr.data-index]="$index" class="sf__array-item">
                <nz-card>
                  <sf-item [formProperty]="i" />
                  @if (showRemove) {
                    <span class="sf__array-remove" (click)="removeItem($index)" [attr.title]="removeTitle">
                      <nz-icon nzType="delete" />
                    </span>
                  }
                </nz-card>
              </div>
            }
          }
        </div>
        @if (!ui.onlyVisual && showError) {
          <div class="ant-form-explain">{{ error }}</div>
        }
        @if (schema.description) {
          <div [innerHTML]="ui._description" class="ant-form-extra"></div>
        }
      </div>
    </div>
  </nz-form-item>`,
      host: {
        "[class.sf__array]": "true"
      },
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var BooleanWidget = class _BooleanWidget extends ControlUIWidget {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵBooleanWidget_BaseFactory;
    return function BooleanWidget_Factory(__ngFactoryType__) {
      return (ɵBooleanWidget_BaseFactory || (ɵBooleanWidget_BaseFactory = ɵɵgetInheritedFactory(_BooleanWidget)))(__ngFactoryType__ || _BooleanWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _BooleanWidget,
    selectors: [["sf-boolean"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 12,
    consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngModelChange", "ngModel", "nzDisabled", "nzSize", "nzCheckedChildren", "nzUnCheckedChildren", "nzLoading"]],
    template: function BooleanWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-switch", 1);
        ɵɵlistener("ngModelChange", function BooleanWidget_Template_nz_switch_ngModelChange_1_listener($event) {
          return ctx.setValue($event);
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance();
        ɵɵproperty("ngModel", ctx.value)("nzDisabled", ctx.disabled)("nzSize", ctx.ui.size)("nzCheckedChildren", ctx.ui.checkedChildren)("nzUnCheckedChildren", ctx.ui.unCheckedChildren)("nzLoading", ctx.ui.loading);
      }
    },
    dependencies: [NgControlStatus, NgModel, NzSwitchComponent, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BooleanWidget, [{
    type: Component,
    args: [{
      selector: "sf-boolean",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-switch
      [ngModel]="value"
      (ngModelChange)="setValue($event)"
      [nzDisabled]="disabled"
      [nzSize]="ui.size!"
      [nzCheckedChildren]="ui.checkedChildren!"
      [nzUnCheckedChildren]="ui.unCheckedChildren!"
      [nzLoading]="ui.loading"
    />
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var CheckboxWidget = class _CheckboxWidget extends ControlUIWidget {
  data = [];
  allChecked = false;
  indeterminate = false;
  grid_span;
  labelTitle = ``;
  inited = false;
  reset(value) {
    this.inited = false;
    getData(this.schema, this.ui, value).subscribe((list) => {
      this.data = list;
      this.allChecked = false;
      this.indeterminate = false;
      this.labelTitle = list.length === 0 ? "" : this.schema.title;
      const {
        span
      } = this.ui;
      this.grid_span = span && span > 0 ? span : 0;
      this.updateAllChecked();
      this.inited = true;
      this.detectChanges();
    });
  }
  _setValue(value) {
    this.setValue(value);
    this.detectChanges();
    this.notifyChange(value);
  }
  notifySet() {
    const checkList = this.data.filter((w) => w.checked);
    this.updateAllChecked().setValue(checkList.map((item) => item.value));
    this.notifyChange(checkList);
  }
  groupInGridChange(values) {
    this.data.forEach((item) => item.checked = values.indexOf(item.value) !== -1);
    this.notifySet();
  }
  onAllChecked() {
    this.data.forEach((item) => item.checked = this.allChecked);
    this.notifySet();
  }
  updateAllChecked() {
    if (this.data.every((item) => item.checked !== true)) {
      this.allChecked = false;
      this.indeterminate = false;
    } else if (this.data.every((item) => item.checked === true)) {
      this.allChecked = true;
      this.indeterminate = false;
    } else {
      this.indeterminate = true;
    }
    this.detectChanges();
    return this;
  }
  notifyChange(res) {
    if (this.ui.change) this.ui.change(res);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxWidget_BaseFactory;
    return function CheckboxWidget_Factory(__ngFactoryType__) {
      return (ɵCheckboxWidget_BaseFactory || (ɵCheckboxWidget_BaseFactory = ɵɵgetInheritedFactory(_CheckboxWidget)))(__ngFactoryType__ || _CheckboxWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _CheckboxWidget,
    selectors: [["sf-checkbox"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 8,
    consts: [["all", ""], [3, "id", "schema", "ui", "showError", "error", "showTitle", "title"], ["nz-checkbox", "", 1, "sf__checkbox-all", "mr-sm", 3, "ngModel", "nzIndeterminate"], ["nz-checkbox", "", 1, "sf__checkbox-all", "mr-sm", 3, "ngModelChange", "ngModel", "nzIndeterminate"], ["nz-checkbox", "", 3, "nzDisabled", "ngModel"], ["nz-checkbox", "", 3, "ngModelChange", "nzDisabled", "ngModel"], [1, "sf__optional"], ["nz-tooltip", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"], [1, "sf__checkbox-list"], [3, "ngTemplateOutlet"], [3, "ngModelChange", "ngModel", "nzOptions"], [1, "sf__checkbox-list", 3, "nzOnChange"], ["nz-row", ""], ["nz-col", "", 3, "nzSpan"], ["nz-checkbox", "", 3, "nzValue", "ngModel", "nzDisabled"]],
    template: function CheckboxWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, CheckboxWidget_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementStart(2, "sf-item-wrap", 1);
        ɵɵconditionalCreate(3, CheckboxWidget_Conditional_3_Template, 2, 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", true)("title", ctx.labelTitle);
        ɵɵadvance();
        ɵɵconditional(ctx.inited ? 3 : -1);
      }
    },
    dependencies: [NgTemplateOutlet, NgControlStatus, NgModel, NzTransitionPatchDirective, NzCheckboxComponent, NzCheckboxGroupComponent, NzCheckboxWrapperComponent, NzColDirective, NzRowDirective, NzIconDirective, NzTooltipDirective, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxWidget, [{
    type: Component,
    args: [{
      selector: "sf-checkbox",
      template: `<ng-template #all>
      @if (ui.checkAll) {
        <label
          nz-checkbox
          class="sf__checkbox-all mr-sm"
          [(ngModel)]="allChecked"
          (ngModelChange)="onAllChecked()"
          [nzIndeterminate]="indeterminate"
        >
          {{ ui.checkAllText || l.checkAllText }}
        </label>
      }
    </ng-template>
    <sf-item-wrap
      [id]="id"
      [schema]="schema"
      [ui]="ui"
      [showError]="showError"
      [error]="error"
      [showTitle]="true"
      [title]="labelTitle"
    >
      @if (inited) {
        @if (data.length === 0) {
          <label nz-checkbox [nzDisabled]="disabled" [ngModel]="value" (ngModelChange)="_setValue($event)">
            {{ schema.title }}
            <span class="sf__optional">
              {{ ui.optional }}
              @if (oh) {
                <nz-icon
                  nz-tooltip
                  [nzTooltipTitle]="oh.text"
                  [nzTooltipPlacement]="oh.placement"
                  [nzTooltipTrigger]="oh.trigger"
                  [nzTooltipOverlayClassName]="oh.overlayClassName"
                  [nzTooltipOverlayStyle]="oh.overlayStyle"
                  [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                  [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                  [nzType]="oh.icon!"
                />
              }
            </span>
          </label>
        } @else {
          @if (grid_span === 0) {
            <ng-template [ngTemplateOutlet]="all" />
            <nz-checkbox-group [ngModel]="value" [nzOptions]="$any(data)" (ngModelChange)="groupInGridChange($event)" />
          } @else {
            <nz-checkbox-wrapper class="sf__checkbox-list" (nzOnChange)="groupInGridChange($event)">
              <div nz-row>
                @if (ui.checkAll) {
                  <div nz-col [nzSpan]="grid_span">
                    <ng-template [ngTemplateOutlet]="all" />
                  </div>
                }
                @for (i of data; track $index) {
                  <div nz-col [nzSpan]="grid_span">
                    <label nz-checkbox [nzValue]="i.value" [ngModel]="i.checked" [nzDisabled]="i.disabled">
                      {{ i.label }}
                    </label>
                  </div>
                }
              </div>
            </nz-checkbox-wrapper>
          }
        }
      }
    </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var CustomWidget = class _CustomWidget extends ControlUIWidget {
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵCustomWidget_BaseFactory;
    return function CustomWidget_Factory(__ngFactoryType__) {
      return (ɵCustomWidget_BaseFactory || (ɵCustomWidget_BaseFactory = ɵɵgetInheritedFactory(_CustomWidget)))(__ngFactoryType__ || _CustomWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomWidget,
    selectors: [["sf-custom"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 12,
    consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function CustomWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 0);
        ɵɵtemplate(1, CustomWidget_ng_template_1_Template, 0, 0, "ng-template", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance();
        ɵɵproperty("ngTemplateOutlet", ctx.ui._render)("ngTemplateOutletContext", ɵɵpureFunction3(8, _c2, ctx, ctx.schema, ctx.ui));
      }
    },
    dependencies: [NgTemplateOutlet, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomWidget, [{
    type: Component,
    args: [{
      selector: "sf-custom",
      template: `
    <sf-item-wrap
      [id]="id"
      [schema]="schema"
      [ui]="ui"
      [showError]="showError"
      [error]="error"
      [showTitle]="schema.title"
    >
      <ng-template
        [ngTemplateOutlet]="$any(ui)._render"
        [ngTemplateOutletContext]="{ $implicit: this, schema: schema, ui: ui }"
      />
    </sf-item-wrap>
  `,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var DateWidget = class _DateWidget extends ControlUIWidget {
  startFormat;
  endFormat;
  flatRange = false;
  mode;
  displayValue = null;
  displayFormat;
  i;
  ngOnInit() {
    const {
      mode,
      end,
      displayFormat,
      allowClear,
      showToday
    } = this.ui;
    this.mode = mode || "date";
    this.flatRange = end != null;
    this.startFormat = this.ui._format;
    if (this.flatRange) {
      this.mode = "range";
      const endUi = this.endProperty.ui;
      this.endFormat = endUi.format ? endUi._format : this.startFormat;
    }
    if (!displayFormat) {
      switch (this.mode) {
        case "year":
          this.displayFormat = `yyyy`;
          break;
        case "month":
          this.displayFormat = `yyyy-MM`;
          break;
        case "week":
          this.displayFormat = `yyyy-ww`;
          break;
      }
    } else {
      this.displayFormat = displayFormat;
    }
    this.i = {
      allowClear: toBool(allowClear, true),
      // nz-date-picker
      showToday: toBool(showToday, true)
    };
  }
  reset(value) {
    const toDateOptions = {
      formatString: this.startFormat,
      defaultValue: null
    };
    if (Array.isArray(value)) {
      value = value.map((v) => toDate(v, toDateOptions));
    } else {
      value = toDate(value, toDateOptions);
    }
    if (this.flatRange) {
      const endValue = toDate(this.endProperty.formData, {
        formatString: this.endFormat || this.startFormat,
        defaultValue: null
      });
      this.displayValue = value == null || endValue == null ? [] : [value, endValue];
    } else {
      this.displayValue = value;
    }
    this.detectChanges();
    if (this.displayValue) {
      setTimeout(() => this._change(this.displayValue, false));
    }
  }
  _change(value, emitModelChange = true) {
    if (emitModelChange && this.ui.change) {
      this.ui.change(value);
    }
    if (value == null || Array.isArray(value) && value.length < 2) {
      this.setValue(null);
      this.setEnd(null);
      return;
    }
    const res = Array.isArray(value) ? [format(value[0], this.startFormat), format(value[1], this.endFormat || this.startFormat)] : format(value, this.startFormat);
    if (this.flatRange) {
      this.setValue(res[0]);
      this.setEnd(res[1]);
    } else {
      this.setValue(res);
    }
  }
  _openChange(status) {
    if (this.ui.onOpenChange) this.ui.onOpenChange(status);
  }
  _ok(value) {
    if (this.ui.onOk) this.ui.onOk(value);
  }
  get endProperty() {
    return this.formProperty.parent.properties[this.ui.end];
  }
  setEnd(value) {
    if (!this.flatRange) return;
    this.endProperty.setValue(value, true);
    this.endProperty.updateValueAndValidity();
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵDateWidget_BaseFactory;
    return function DateWidget_Factory(__ngFactoryType__) {
      return (ɵDateWidget_BaseFactory || (ɵDateWidget_BaseFactory = ɵɵgetInheritedFactory(_DateWidget)))(__ngFactoryType__ || _DateWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _DateWidget,
    selectors: [["sf-date"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 7,
    consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "class", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzRenderExtraFooter", "nzInputReadOnly", "nzInline"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "class", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzInputReadOnly", "nzInline"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "class", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzRanges", "nzShowTime", "nzSeparator", "nzShowWeekNumber", "nzMode", "nzInputReadOnly", "nzInline"], [3, "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "class", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzShowTime", "nzShowToday", "nzShowWeekNumber", "nzInputReadOnly", "nzInline"], [3, "ngModelChange", "nzOnOpenChange", "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzRenderExtraFooter", "nzInputReadOnly", "nzInline"], [3, "ngModelChange", "nzOnOpenChange", "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzInputReadOnly", "nzInline"], [3, "ngModelChange", "nzOnOpenChange", "nzOnOk", "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzRanges", "nzShowTime", "nzSeparator", "nzShowWeekNumber", "nzMode", "nzInputReadOnly", "nzInline"], [3, "ngModelChange", "nzOnOpenChange", "nzOnOk", "nzId", "nzDisabled", "nzSize", "nzFormat", "ngModel", "nzAllowClear", "nzDisabledDate", "nzLocale", "nzPlaceHolder", "nzPopupStyle", "nzDropdownClassName", "nzDisabledTime", "nzRenderExtraFooter", "nzShowTime", "nzShowToday", "nzShowWeekNumber", "nzInputReadOnly", "nzInline"]],
    template: function DateWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 0);
        ɵɵconditionalCreate(1, DateWidget_Case_1_Template, 1, 16, "nz-year-picker", 1)(2, DateWidget_Case_2_Template, 1, 16, "nz-month-picker", 1)(3, DateWidget_Case_3_Template, 1, 15, "nz-week-picker", 2)(4, DateWidget_Case_4_Template, 1, 22, "nz-range-picker", 3)(5, DateWidget_Case_5_Template, 1, 20, "nz-date-picker", 4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        let tmp_6_0;
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance();
        ɵɵconditional((tmp_6_0 = ctx.mode) === "year" ? 1 : tmp_6_0 === "month" ? 2 : tmp_6_0 === "week" ? 3 : tmp_6_0 === "range" ? 4 : 5);
      }
    },
    dependencies: [NgControlStatus, NgModel, NzDatePickerComponent, NzRangePickerComponent, NzMonthPickerComponent, NzYearPickerComponent, NzWeekPickerComponent, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateWidget, [{
    type: Component,
    args: [{
      selector: "sf-date",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    @switch (mode) {
      @case ('year') {
        <nz-year-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [class]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
        />
      }
      @case ('month') {
        <nz-month-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [class]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
        />
      }
      @case ('week') {
        <nz-week-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [class]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOpenChange)="_openChange($event)"
        />
      }
      @case ('range') {
        <nz-range-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [class]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzDisabledTime]="ui.disabledTime"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzRanges]="ui.ranges"
          [nzShowTime]="ui.showTime"
          [nzSeparator]="ui.separator"
          [nzShowWeekNumber]="ui.showWeekNumber || false"
          [nzMode]="$any(ui.rangeMode)"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOk)="_ok($event)"
        />
      }
      @default {
        <nz-date-picker
          [nzId]="id"
          [nzDisabled]="disabled"
          [nzSize]="ui.size!"
          [nzFormat]="displayFormat"
          [(ngModel)]="displayValue"
          (ngModelChange)="_change($event)"
          [nzAllowClear]="i.allowClear"
          [class]="ui.className!"
          [nzDisabledDate]="ui.disabledDate"
          [nzLocale]="ui.locale!"
          [nzPlaceHolder]="ui.placeholder!"
          [nzPopupStyle]="ui.popupStyle!"
          [nzDropdownClassName]="ui.dropdownClassName"
          (nzOnOpenChange)="_openChange($event)"
          [nzDisabledTime]="ui.disabledTime"
          [nzRenderExtraFooter]="ui.renderExtraFooter"
          [nzShowTime]="ui.showTime"
          [nzShowToday]="i.showToday"
          [nzShowWeekNumber]="ui.showWeekNumber || false"
          [nzInputReadOnly]="ui.inputReadOnly"
          [nzInline]="ui.inline!"
          (nzOnOk)="_ok($event)"
        />
      }
    }
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var NumberWidget = class _NumberWidget extends ControlUIWidget {
  min;
  max;
  step;
  formatter = (value) => value.toString();
  parser = (value) => +value;
  width = "";
  ngOnInit() {
    const {
      minimum,
      exclusiveMinimum,
      maximum,
      exclusiveMaximum,
      multipleOf,
      type
    } = this.schema;
    this.step = multipleOf || 1;
    if (typeof minimum !== "undefined") {
      this.min = exclusiveMinimum ? minimum + this.step : minimum;
    }
    if (typeof maximum !== "undefined") {
      this.max = exclusiveMaximum ? maximum - this.step : maximum;
    }
    if (type === "integer") {
      this.min = Math.trunc(this.min);
      this.max = Math.trunc(this.max);
      this.step = Math.trunc(this.step);
    }
    const ui = this.ui;
    if (ui.prefix != null) {
      ui.formatter = (value) => value == null ? "" : `${ui.prefix} ${value}`;
      ui.parser = (value) => +value.replace(`${ui.prefix} `, "");
    }
    if (ui.unit != null) {
      ui.formatter = (value) => value == null ? "" : `${value} ${ui.unit}`;
      ui.parser = (value) => +value.replace(` ${ui.unit}`, "");
    }
    if (ui.formatter) this.formatter = ui.formatter;
    if (ui.parser) this.parser = ui.parser;
    this.width = typeof ui.widgetWidth === "number" ? `${ui.widgetWidth}px` : ui.widgetWidth ?? "90px";
  }
  _setValue(val) {
    this.setValue(this.schema.type === "integer" ? Math.floor(val) : val);
    this.ui.change?.(this.value);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵNumberWidget_BaseFactory;
    return function NumberWidget_Factory(__ngFactoryType__) {
      return (ɵNumberWidget_BaseFactory || (ɵNumberWidget_BaseFactory = ɵɵgetInheritedFactory(_NumberWidget)))(__ngFactoryType__ || _NumberWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _NumberWidget,
    selectors: [["sf-number"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 21,
    consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngModelChange", "nzId", "ngModel", "nzDisabled", "nzSize", "nzMin", "nzMax", "nzStep", "nzFormatter", "nzParser", "nzPrecision", "nzPlaceHolder"]],
    template: function NumberWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-input-number", 1);
        ɵɵlistener("ngModelChange", function NumberWidget_Template_nz_input_number_ngModelChange_1_listener($event) {
          return ctx._setValue($event);
        });
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance();
        ɵɵstyleProp("width", ctx.width);
        ɵɵclassProp("ant-input-number__hide-step", ctx.ui.hideStep);
        ɵɵproperty("nzId", ctx.id)("ngModel", ctx.value)("nzDisabled", ctx.disabled)("nzSize", ctx.ui.size)("nzMin", ctx.min)("nzMax", ctx.max)("nzStep", ctx.step)("nzFormatter", ctx.formatter)("nzParser", ctx.parser)("nzPrecision", ctx.ui.precision || null)("nzPlaceHolder", ctx.ui.placeholder || "");
      }
    },
    dependencies: [NgControlStatus, NgModel, NzInputNumberComponent, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberWidget, [{
    type: Component,
    args: [{
      selector: "sf-number",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-input-number
      [nzId]="id"
      [ngModel]="value"
      (ngModelChange)="_setValue($event)"
      [nzDisabled]="disabled"
      [nzSize]="ui.size!"
      [nzMin]="min"
      [nzMax]="max"
      [nzStep]="step"
      [nzFormatter]="formatter"
      [nzParser]="parser"
      [nzPrecision]="ui.precision || null"
      [nzPlaceHolder]="ui.placeholder || ''"
      [style.width]="width"
      [class.ant-input-number__hide-step]="ui.hideStep"
    />
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var ObjectWidget = class _ObjectWidget extends ObjectLayoutWidget {
  grid;
  type = "default";
  list = [];
  title;
  showExpand = true;
  expand = true;
  ngOnInit() {
    const {
      formProperty,
      ui
    } = this;
    const {
      grid,
      showTitle,
      type
    } = ui;
    this.showExpand = toBool(ui.showExpand, true);
    this.expand = toBool(ui.expand, true);
    this.type = type ?? "default";
    if (this.type === "card" || !formProperty.isRoot() && !(formProperty.parent instanceof ArrayProperty) && showTitle === true) {
      this.title = this.schema.title;
    }
    this.grid = grid;
    const list = [];
    for (const key of formProperty.propertiesId) {
      const property = formProperty.properties[key];
      const item = {
        property,
        grid: property.ui.grid || grid || {},
        spanLabelFixed: property.ui.spanLabelFixed,
        show: property.ui.hidden === false
      };
      list.push(item);
    }
    this.list = list;
  }
  changeExpand() {
    if (!this.showExpand) {
      return;
    }
    this.expand = !this.expand;
    this.detectChanges(true);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵObjectWidget_BaseFactory;
    return function ObjectWidget_Factory(__ngFactoryType__) {
      return (ɵObjectWidget_BaseFactory || (ɵObjectWidget_BaseFactory = ɵɵgetInheritedFactory(_ObjectWidget)))(__ngFactoryType__ || _ObjectWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _ObjectWidget,
    selectors: [["sf-object"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 1,
    consts: [["default", ""], ["cardTitleTpl", ""], [1, "sf__object-card", 3, "nzTitle", "nzExtra", "nzSize", "nzActions", "nzBodyStyle", "nzBordered", "sf__object-card-fold"], [3, "ngTemplateOutlet"], [1, "sf__title"], ["nz-row", "", 3, "nzGutter"], ["nz-col", "", 3, "nzSpan", "nzOffset", "nzXs", "nzSm", "nzMd", "nzLg", "nzXl", "nzXXl"], [3, "formProperty", "fixed-label"], [1, "sf__object-card", 3, "nzTitle", "nzExtra", "nzSize", "nzActions", "nzBodyStyle", "nzBordered"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "click"], [1, "mr-xs", "text-xs", 3, "nzType"], [1, "sf__optional"], ["nz-tooltip", "", 3, "nzTooltipTitle", "nzTooltipPlacement", "nzTooltipTrigger", "nzTooltipColor", "nzTooltipOverlayClassName", "nzTooltipOverlayStyle", "nzTooltipMouseEnterDelay", "nzTooltipMouseLeaveDelay", "nzType"]],
    template: function ObjectWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ObjectWidget_ng_template_0_Template, 3, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(2, ObjectWidget_Conditional_2_Template, 4, 12, "nz-card", 2)(3, ObjectWidget_Conditional_3_Template, 1, 1, null, 3);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵconditional(ctx.type === "card" ? 2 : 3);
      }
    },
    dependencies: [NgTemplateOutlet, NzTransitionPatchDirective, NzCardComponent, NzColDirective, NzRowDirective, NzIconDirective, NzTooltipDirective, SFItemComponent, SFFixedDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObjectWidget, [{
    type: Component,
    args: [{
      selector: "sf-object",
      template: `<ng-template #default let-noTitle>
      @if (!noTitle && title) {
        <div class="sf__title">{{ title }}</div>
      }
      @if (grid) {
        <div nz-row [nzGutter]="grid.gutter">
          @for (i of list; track $index) {
            @if (i.property.visible && i.show) {
              <div
                nz-col
                [nzSpan]="i.grid.span"
                [nzOffset]="i.grid.offset"
                [nzXs]="i.grid.xs"
                [nzSm]="i.grid.sm"
                [nzMd]="i.grid.md"
                [nzLg]="i.grid.lg"
                [nzXl]="i.grid.xl"
                [nzXXl]="i.grid.xxl"
              >
                <sf-item [formProperty]="i.property" [fixed-label]="i.spanLabelFixed" />
              </div>
            }
          }
        </div>
      } @else {
        @for (i of list; track $index) {
          @if (i.property.visible && i.show) {
            <sf-item [formProperty]="i.property" [fixed-label]="i.spanLabelFixed" />
          }
        }
      }
    </ng-template>
    @if (type === 'card') {
      <nz-card
        [nzTitle]="cardTitleTpl"
        [nzExtra]="ui.cardExtra"
        [nzSize]="ui.cardSize || 'small'"
        [nzActions]="ui.cardActions || []"
        [nzBodyStyle]="ui.cardBodyStyle!"
        [nzBordered]="ui.cardBordered || true"
        class="sf__object-card"
        [class.sf__object-card-fold]="!expand"
      >
        <ng-template #cardTitleTpl>
          <div [class.point]="showExpand" (click)="changeExpand()">
            @if (showExpand) {
              <nz-icon [nzType]="expand ? 'down' : 'up'" class="mr-xs text-xs" />
            }
            {{ title }}
            @if (ui.optional || oh) {
              <span class="sf__optional">
                {{ ui.optional }}
                @if (oh) {
                  <nz-icon
                    nz-tooltip
                    [nzTooltipTitle]="oh.text"
                    [nzTooltipPlacement]="oh.placement"
                    [nzTooltipTrigger]="oh.trigger"
                    [nzTooltipColor]="oh.bgColor"
                    [nzTooltipOverlayClassName]="oh.overlayClassName"
                    [nzTooltipOverlayStyle]="oh.overlayStyle"
                    [nzTooltipMouseEnterDelay]="oh.mouseEnterDelay"
                    [nzTooltipMouseLeaveDelay]="oh.mouseLeaveDelay"
                    [nzType]="oh.icon!"
                  />
                }
              </span>
            }
          </div>
        </ng-template>
        <ng-template [ngTemplateOutlet]="default" [ngTemplateOutletContext]="{ $implicit: true }" />
      </nz-card>
    } @else {
      <ng-template [ngTemplateOutlet]="default" />
    }`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var RadioWidget = class _RadioWidget extends ControlUIWidget {
  data = [];
  styleType;
  reset(value) {
    this.styleType = (this.ui.styleType || "default") === "default";
    getData(this.schema, this.ui, value).subscribe((list) => {
      this.data = list;
      this.detectChanges();
    });
  }
  _setValue(value) {
    this.setValue(value);
    if (this.ui.change) this.ui.change(value);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRadioWidget_BaseFactory;
    return function RadioWidget_Factory(__ngFactoryType__) {
      return (ɵRadioWidget_BaseFactory || (ɵRadioWidget_BaseFactory = ɵɵgetInheritedFactory(_RadioWidget)))(__ngFactoryType__ || _RadioWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _RadioWidget,
    selectors: [["sf-radio"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 11,
    consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngModelChange", "nzSize", "nzName", "ngModel", "nzButtonStyle"], ["nz-radio", "", 3, "nzValue", "nzDisabled"], [3, "innerHTML"], ["nz-radio-button", "", 3, "nzValue", "nzDisabled"]],
    template: function RadioWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-radio-group", 1);
        ɵɵlistener("ngModelChange", function RadioWidget_Template_nz_radio_group_ngModelChange_1_listener($event) {
          return ctx._setValue($event);
        });
        ɵɵconditionalCreate(2, RadioWidget_Conditional_2_Template, 2, 0)(3, RadioWidget_Conditional_3_Template, 2, 0);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance();
        ɵɵproperty("nzSize", ctx.ui.size)("nzName", ctx.id)("ngModel", ctx.value)("nzButtonStyle", ctx.ui.buttonStyle || "outline");
        ɵɵadvance();
        ɵɵconditional(ctx.styleType ? 2 : 3);
      }
    },
    dependencies: [NgControlStatus, NgModel, NzRadioComponent, NzRadioGroupComponent, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioWidget, [{
    type: Component,
    args: [{
      selector: "sf-radio",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-radio-group
      [nzSize]="ui.size!"
      [nzName]="id"
      [ngModel]="value"
      (ngModelChange)="_setValue($event)"
      [nzButtonStyle]="ui.buttonStyle || 'outline'"
    >
      @if (styleType) {
        @for (option of data; track $index) {
          <label nz-radio [nzValue]="option.value" [nzDisabled]="disabled || option.disabled">
            <span [innerHTML]="option.label"></span>
          </label>
        }
      } @else {
        @for (option of data; track $index) {
          <label nz-radio-button [nzValue]="option.value" [nzDisabled]="disabled || option.disabled">
            <span [innerHTML]="option.label"></span>
          </label>
        }
      }
    </nz-radio-group>
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var SelectWidget = class _SelectWidget extends ControlUIWidget {
  search$ = new Subject();
  i;
  data = [];
  _value;
  hasGroup = false;
  loading = false;
  checkGroup(list) {
    this.hasGroup = (list || []).filter((w) => w.group === true).length > 0;
  }
  ngOnInit() {
    const {
      autoClearSearchValue,
      borderless,
      autoFocus,
      dropdownMatchSelectWidth,
      serverSearch,
      maxMultipleCount,
      mode,
      showSearch,
      tokenSeparators,
      maxTagCount,
      compareWith,
      optionHeightPx,
      optionOverflowSize,
      showArrow
    } = this.ui;
    this.i = {
      autoClearSearchValue: toBool(autoClearSearchValue, true),
      borderless: toBool(borderless, false),
      autoFocus: toBool(autoFocus, false),
      dropdownMatchSelectWidth: toBool(dropdownMatchSelectWidth, true),
      serverSearch: toBool(serverSearch, false),
      maxMultipleCount: maxMultipleCount || Infinity,
      mode: mode || "default",
      showSearch: toBool(showSearch, true),
      tokenSeparators: tokenSeparators || [],
      maxTagCount: maxTagCount || Infinity,
      optionHeightPx: optionHeightPx || 32,
      optionOverflowSize: optionOverflowSize || 8,
      showArrow: toBool(showArrow, true),
      compareWith: compareWith || ((o1, o2) => o1 === o2)
    };
    const onSearch = this.ui.onSearch;
    if (onSearch) {
      this.search$.pipe(takeUntil(this.sfItemComp.destroy$), distinctUntilChanged(), debounceTime(this.ui.searchDebounceTime || 300), switchMap((text) => onSearch(text)), catchError(() => [])).subscribe((list) => {
        this.data = list;
        this.checkGroup(list);
        this.loading = false;
        this.detectChanges();
      });
    }
  }
  reset(value) {
    const onSearch = this.ui.onSearch;
    getData(this.schema, this.ui, value).subscribe((list) => {
      this._value = value;
      if (onSearch == null) this.data = list;
      this.checkGroup(list);
      this.detectChanges();
    });
    if (value && onSearch != null) this.search$.next(value);
  }
  change(values) {
    if (this.ui.change) {
      this.ui.change(values, this.getOrgData(values));
    }
    this.setValue(values == null ? this.ui.clearValue : values);
  }
  getOrgData(values) {
    const srv = this.injector.get(ArrayService);
    if (!Array.isArray(values)) {
      return srv.findTree(this.data, (item) => item.value === values);
    }
    return values.map((value) => srv.findTree(this.data, (item) => item.value === value));
  }
  openChange(status) {
    if (this.ui.openChange) {
      this.ui.openChange(status);
    }
  }
  scrollToBottom() {
    if (this.ui.scrollToBottom) {
      this.ui.scrollToBottom();
    }
  }
  onSearch(value) {
    if (this.ui.onSearch) {
      this.loading = true;
      this.search$.next(value);
    }
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectWidget_BaseFactory;
    return function SelectWidget_Factory(__ngFactoryType__) {
      return (ɵSelectWidget_BaseFactory || (ɵSelectWidget_BaseFactory = ɵɵgetInheritedFactory(_SelectWidget)))(__ngFactoryType__ || _SelectWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _SelectWidget,
    selectors: [["sf-select"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 39,
    consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "ngModelChange", "nzOpenChange", "nzOnSearch", "nzScrollToBottom", "nzId", "nzDisabled", "ngModel", "nzSize", "nzPlaceHolder", "nzNotFoundContent", "nzDropdownClassName", "nzAllowClear", "nzDropdownStyle", "nzCustomTemplate", "nzSuffixIcon", "nzRemoveIcon", "nzClearIcon", "nzMenuItemSelectedIcon", "nzMaxTagPlaceholder", "nzDropdownRender", "nzAutoClearSearchValue", "nzBorderless", "nzAutoFocus", "nzDropdownMatchSelectWidth", "nzServerSearch", "nzMaxMultipleCount", "nzMode", "nzShowSearch", "nzShowArrow", "nzTokenSeparators", "nzMaxTagCount", "compareWith", "nzOptionHeightPx", "nzOptionOverflowSize"], ["nzDisabled", "", "nzCustomContent", ""], [3, "nzLabel", "nzValue", "nzHide", "nzDisabled"], [3, "nzLabel"], [3, "nzLabel", "nzValue", "nzDisabled", "nzHide"], ["nzType", "loading"]],
    template: function SelectWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 0)(1, "nz-select", 1);
        ɵɵtwoWayListener("ngModelChange", function SelectWidget_Template_nz_select_ngModelChange_1_listener($event) {
          ɵɵtwoWayBindingSet(ctx._value, $event) || (ctx._value = $event);
          return $event;
        });
        ɵɵlistener("ngModelChange", function SelectWidget_Template_nz_select_ngModelChange_1_listener($event) {
          return ctx.change($event);
        })("nzOpenChange", function SelectWidget_Template_nz_select_nzOpenChange_1_listener($event) {
          return ctx.openChange($event);
        })("nzOnSearch", function SelectWidget_Template_nz_select_nzOnSearch_1_listener($event) {
          return ctx.onSearch($event);
        })("nzScrollToBottom", function SelectWidget_Template_nz_select_nzScrollToBottom_1_listener() {
          return ctx.scrollToBottom();
        });
        ɵɵconditionalCreate(2, SelectWidget_Conditional_2_Template, 2, 0);
        ɵɵconditionalCreate(3, SelectWidget_Conditional_3_Template, 2, 0);
        ɵɵconditionalCreate(4, SelectWidget_Conditional_4_Template, 3, 1, "nz-option", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance();
        ɵɵproperty("nzId", ctx.id)("nzDisabled", ctx.disabled);
        ɵɵtwoWayProperty("ngModel", ctx._value);
        ɵɵproperty("nzSize", ctx.ui.size)("nzPlaceHolder", ctx.ui.placeholder)("nzNotFoundContent", ctx.ui.notFoundContent)("nzDropdownClassName", ctx.ui.dropdownClassName)("nzAllowClear", ctx.ui.allowClear)("nzDropdownStyle", ctx.ui.dropdownStyle)("nzCustomTemplate", ctx.ui.customTemplate)("nzSuffixIcon", ctx.ui.suffixIcon)("nzRemoveIcon", ctx.ui.removeIcon)("nzClearIcon", ctx.ui.clearIcon)("nzMenuItemSelectedIcon", ctx.ui.menuItemSelectedIcon)("nzMaxTagPlaceholder", ctx.ui.maxTagPlaceholder)("nzDropdownRender", ctx.ui.dropdownRender)("nzAutoClearSearchValue", ctx.i.autoClearSearchValue)("nzBorderless", ctx.i.borderless)("nzAutoFocus", ctx.i.autoFocus)("nzDropdownMatchSelectWidth", ctx.i.dropdownMatchSelectWidth)("nzServerSearch", ctx.i.serverSearch)("nzMaxMultipleCount", ctx.i.maxMultipleCount)("nzMode", ctx.i.mode)("nzShowSearch", ctx.i.showSearch)("nzShowArrow", ctx.i.showArrow)("nzTokenSeparators", ctx.i.tokenSeparators)("nzMaxTagCount", ctx.i.maxTagCount)("compareWith", ctx.i.compareWith)("nzOptionHeightPx", ctx.i.optionHeightPx)("nzOptionOverflowSize", ctx.i.optionOverflowSize);
        ɵɵadvance();
        ɵɵconditional(!ctx.loading && !ctx.hasGroup ? 2 : -1);
        ɵɵadvance();
        ɵɵconditional(!ctx.loading && ctx.hasGroup ? 3 : -1);
        ɵɵadvance();
        ɵɵconditional(ctx.loading ? 4 : -1);
      }
    },
    dependencies: [NgControlStatus, NgModel, NzTransitionPatchDirective, NzIconDirective, NzOptionComponent, NzSelectComponent, NzOptionGroupComponent, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectWidget, [{
    type: Component,
    args: [{
      selector: "sf-select",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <nz-select
      [nzId]="id"
      [nzDisabled]="disabled"
      [(ngModel)]="_value"
      (ngModelChange)="change($event)"
      [nzSize]="ui.size!"
      [nzPlaceHolder]="ui.placeholder!"
      [nzNotFoundContent]="ui.notFoundContent"
      [nzDropdownClassName]="ui.dropdownClassName!"
      [nzAllowClear]="ui.allowClear"
      [nzDropdownStyle]="ui.dropdownStyle!"
      [nzCustomTemplate]="ui.customTemplate!"
      [nzSuffixIcon]="ui.suffixIcon!"
      [nzRemoveIcon]="ui.removeIcon!"
      [nzClearIcon]="ui.clearIcon!"
      [nzMenuItemSelectedIcon]="ui.menuItemSelectedIcon!"
      [nzMaxTagPlaceholder]="ui.maxTagPlaceholder!"
      [nzDropdownRender]="ui.dropdownRender!"
      [nzAutoClearSearchValue]="i.autoClearSearchValue"
      [nzBorderless]="i.borderless"
      [nzAutoFocus]="i.autoFocus"
      [nzDropdownMatchSelectWidth]="i.dropdownMatchSelectWidth!"
      [nzServerSearch]="i.serverSearch"
      [nzMaxMultipleCount]="i.maxMultipleCount!"
      [nzMode]="i.mode!"
      [nzShowSearch]="i.showSearch"
      [nzShowArrow]="i.showArrow!"
      [nzTokenSeparators]="i.tokenSeparators!"
      [nzMaxTagCount]="i.maxTagCount!"
      [compareWith]="i.compareWith!"
      [nzOptionHeightPx]="i.optionHeightPx!"
      [nzOptionOverflowSize]="i.optionOverflowSize!"
      (nzOpenChange)="openChange($event)"
      (nzOnSearch)="onSearch($event)"
      (nzScrollToBottom)="scrollToBottom()"
    >
      @if (!loading && !hasGroup) {
        @for (o of data; track $index) {
          <nz-option [nzLabel]="o.label" [nzValue]="o.value" [nzHide]="o.hide" [nzDisabled]="o.disabled" />
        }
      }
      @if (!loading && hasGroup) {
        @for (i of data; track $index) {
          <nz-option-group [nzLabel]="i.label">
            @for (o of i.children; track $index) {
              <nz-option [nzLabel]="o.label" [nzValue]="o.value" [nzDisabled]="o.disabled" [nzHide]="o.hide" />
            }
          </nz-option-group>
        }
      }
      @if (loading) {
        <nz-option nzDisabled nzCustomContent>
          <nz-icon nzType="loading" />
          {{ ui.searchLoadingText }}
        </nz-option>
      }
    </nz-select>
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var StringWidget = class _StringWidget extends ControlUIWidget {
  type;
  change$ = null;
  ngOnInit() {
    const {
      addOnAfter,
      addOnAfterIcon,
      addOnBefore,
      addOnBeforeIcon,
      prefix,
      prefixIcon,
      suffix,
      suffixIcon,
      autofocus
    } = this.ui;
    this.type = addOnAfter || addOnBefore || addOnAfterIcon || addOnBeforeIcon || prefix || prefixIcon || suffix || suffixIcon ? "addon" : "";
    if (autofocus === true) {
      setTimeout(() => {
        this.injector.get(ElementRef).nativeElement.querySelector(`#${this.id}`).focus();
      }, 20);
    }
    this.initChange();
  }
  reset(value) {
    if (!value && this.schema.format === "color") {
      this.setValue("#000000");
    }
  }
  initChange() {
    const dueTime = this.ui.changeDebounceTime;
    const changeFn = this.ui.change;
    if (dueTime == null || dueTime <= 0 || changeFn == null) return;
    this.change$ = new BehaviorSubject(this.value);
    let obs = this.change$.asObservable().pipe(debounceTime(dueTime), takeUntil(this.sfItemComp.destroy$));
    if (this.ui.changeMap != null) {
      obs = obs.pipe(switchMap(this.ui.changeMap));
    }
    obs.subscribe((val) => changeFn(val));
  }
  change(val) {
    this.setValue(val);
    if (this.change$ != null) {
      this.change$.next(val);
      return;
    }
    if (this.ui.change) this.ui.change(val);
  }
  focus(e) {
    if (this.ui.focus) this.ui.focus(e);
  }
  blur(e) {
    if (this.ui.blur) this.ui.blur(e);
  }
  enter(e) {
    if (this.ui.enter) this.ui.enter(e);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵStringWidget_BaseFactory;
    return function StringWidget_Factory(__ngFactoryType__) {
      return (ɵStringWidget_BaseFactory || (ɵStringWidget_BaseFactory = ɵɵgetInheritedFactory(_StringWidget)))(__ngFactoryType__ || _StringWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _StringWidget,
    selectors: [["sf-string"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 7,
    consts: [["ipt", ""], [3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzAddOnBefore", "nzAddOnAfter", "nzAddOnBeforeIcon", "nzAddOnAfterIcon", "nzPrefix", "nzPrefixIcon", "nzSuffix", "nzSuffixIcon"], [3, "ngTemplateOutlet"], ["nz-input", "", 3, "ngModelChange", "keyup.enter", "focus", "blur", "disabled", "nzSize", "nzBorderless", "ngModel"]],
    template: function StringWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 1);
        ɵɵtemplate(1, StringWidget_ng_template_1_Template, 1, 11, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(3, StringWidget_Conditional_3_Template, 2, 9, "nz-input-group", 2)(4, StringWidget_Conditional_4_Template, 1, 1, null, 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance(3);
        ɵɵconditional(ctx.type === "addon" ? 3 : 4);
      }
    },
    dependencies: [NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, NzTransitionPatchDirective, NzInputDirective, NzInputGroupComponent, NzInputGroupWhitSuffixOrPrefixDirective, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StringWidget, [{
    type: Component,
    args: [{
      selector: "sf-string",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <ng-template #ipt>
      <input
        nz-input
        [attr.id]="id"
        [disabled]="disabled"
        [attr.disabled]="disabled"
        [nzSize]="ui.size!"
        [nzBorderless]="ui.borderless"
        [ngModel]="value"
        (ngModelChange)="change($event)"
        [attr.maxLength]="schema.maxLength || null"
        [attr.type]="ui.type || 'text'"
        [attr.placeholder]="ui.placeholder"
        [attr.autocomplete]="ui.autocomplete"
        [attr.autoFocus]="ui.autofocus"
        (keyup.enter)="enter($event)"
        (focus)="focus($event)"
        (blur)="blur($event)"
      />
    </ng-template>

    @if (type === 'addon') {
      <nz-input-group
        [nzAddOnBefore]="ui.addOnBefore"
        [nzAddOnAfter]="ui.addOnAfter"
        [nzAddOnBeforeIcon]="ui.addOnBeforeIcon"
        [nzAddOnAfterIcon]="ui.addOnAfterIcon"
        [nzPrefix]="ui.prefix"
        [nzPrefixIcon]="ui.prefixIcon"
        [nzSuffix]="ui.suffix"
        [nzSuffixIcon]="ui.suffixIcon"
      >
        <ng-template [ngTemplateOutlet]="ipt" />
      </nz-input-group>
    } @else {
      <ng-template [ngTemplateOutlet]="ipt" />
    }
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var TextWidget = class _TextWidget extends ControlUIWidget {
  text = "";
  ngOnInit() {
    this.ui._required = false;
    this.ui.html = toBool(this.ui.html, true);
  }
  reset(value) {
    this.text = value || this.ui.defaultText || "-";
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTextWidget_BaseFactory;
    return function TextWidget_Factory(__ngFactoryType__) {
      return (ɵTextWidget_BaseFactory || (ɵTextWidget_BaseFactory = ɵɵgetInheritedFactory(_TextWidget)))(__ngFactoryType__ || _TextWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _TextWidget,
    selectors: [["sf-text"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 9,
    consts: [[3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "innerHTML"], [3, "innerText"]],
    template: function TextWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 0);
        ɵɵconditionalCreate(1, TextWidget_Conditional_1_Template, 1, 1, "span", 1)(2, TextWidget_Conditional_2_Template, 1, 1, "span", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassProp("sf__text-html", ctx.ui.html);
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance();
        ɵɵconditional(ctx.ui.html ? 1 : 2);
      }
    },
    dependencies: [SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextWidget, [{
    type: Component,
    args: [{
      selector: "sf-text",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
    [class.sf__text-html]="ui.html"
  >
    @if (ui.html) {
      <span [innerHTML]="text"></span>
    } @else {
      <span [innerText]="text"></span>
    }
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var TextareaWidget = class _TextareaWidget extends ControlUIWidget {
  autosize = true;
  ngOnInit() {
    if (this.ui.autosize != null) {
      this.autosize = this.ui.autosize;
    }
    if (this.ui.computeCharacterCount == null) {
      this.ui.computeCharacterCount = (v) => v.length;
    }
  }
  change(val) {
    this.setValue(val);
    if (this.ui.change) this.ui.change(val);
  }
  focus(e) {
    if (this.ui.focus) this.ui.focus(e);
  }
  blur(e) {
    if (this.ui.blur) this.ui.blur(e);
  }
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTextareaWidget_BaseFactory;
    return function TextareaWidget_Factory(__ngFactoryType__) {
      return (ɵTextareaWidget_BaseFactory || (ɵTextareaWidget_BaseFactory = ɵɵgetInheritedFactory(_TextareaWidget)))(__ngFactoryType__ || _TextareaWidget);
    };
  })();
  static ɵcmp = ɵɵdefineComponent({
    type: _TextareaWidget,
    selectors: [["sf-textarea"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 7,
    consts: [["ipt", ""], [3, "id", "schema", "ui", "showError", "error", "showTitle"], [3, "nzMaxCharacterCount", "nzComputeCharacterCount"], [3, "ngTemplateOutlet"], ["nz-input", "", 3, "ngModelChange", "focus", "blur", "disabled", "nzSize", "ngModel", "nzAutosize", "nzBorderless"]],
    template: function TextareaWidget_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "sf-item-wrap", 1);
        ɵɵtemplate(1, TextareaWidget_ng_template_1_Template, 2, 9, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵconditionalCreate(3, TextareaWidget_Conditional_3_Template, 3, 11, "nz-textarea-count", 2)(4, TextareaWidget_Conditional_4_Template, 1, 1, null, 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("id", ctx.id)("schema", ctx.schema)("ui", ctx.ui)("showError", ctx.showError)("error", ctx.error)("showTitle", ctx.schema.title);
        ɵɵadvance(3);
        ɵɵconditional(ctx.ui.maxCharacterCount ? 3 : 4);
      }
    },
    dependencies: [NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, NzTextareaCountComponent, NzInputDirective, NzAutosizeDirective, SFItemWrapComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextareaWidget, [{
    type: Component,
    args: [{
      selector: "sf-textarea",
      template: `<sf-item-wrap
    [id]="id"
    [schema]="schema"
    [ui]="ui"
    [showError]="showError"
    [error]="error"
    [showTitle]="schema.title"
  >
    <ng-template #ipt>
      <textarea
        nz-input
        [attr.id]="id"
        [disabled]="disabled"
        [attr.disabled]="disabled"
        [nzSize]="ui.size!"
        [ngModel]="value"
        (ngModelChange)="change($event)"
        [attr.maxLength]="schema.maxLength || null"
        [attr.placeholder]="ui.placeholder"
        [nzAutosize]="autosize"
        [nzBorderless]="ui.borderless"
        (focus)="focus($event)"
        (blur)="blur($event)"
      >
      </textarea>
    </ng-template>

    @if (ui.maxCharacterCount) {
      <nz-textarea-count
        [nzMaxCharacterCount]="ui.maxCharacterCount"
        [nzComputeCharacterCount]="ui.computeCharacterCount!"
      >
        <textarea
          nz-input
          [attr.id]="id"
          [disabled]="disabled"
          [attr.disabled]="disabled"
          [nzSize]="ui.size!"
          [ngModel]="value"
          (ngModelChange)="change($event)"
          [attr.maxLength]="schema.maxLength || null"
          [attr.placeholder]="ui.placeholder"
          [nzAutosize]="autosize"
          [nzBorderless]="ui.borderless"
          (focus)="focus($event)"
          (blur)="blur($event)"
        >
        </textarea>
      </nz-textarea-count>
    } @else {
      <ng-template [ngTemplateOutlet]="ipt" />
    }
  </sf-item-wrap>`,
      encapsulation: ViewEncapsulation.None,
      // eslint-disable-next-line @angular-eslint/prefer-standalone
      standalone: false
    }]
  }], null, null);
})();
var NzWidgetRegistry = class extends WidgetRegistry {
  constructor() {
    super();
    this.register("object", ObjectWidget);
    this.register("array", ArrayWidget);
    this.register("text", TextWidget);
    this.register("string", StringWidget);
    this.register("number", NumberWidget);
    this.register("integer", NumberWidget);
    this.register("date", DateWidget);
    this.register("radio", RadioWidget);
    this.register("checkbox", CheckboxWidget);
    this.register("boolean", BooleanWidget);
    this.register("textarea", TextareaWidget);
    this.register("select", SelectWidget);
    this.register("custom", CustomWidget);
    this.setDefault(StringWidget);
  }
};
var ZORROS = [NzButtonModule, NzCardModule, NzCheckboxModule, NzDatePickerModule, NzFormModule, NzGridModule, NzIconModule, NzInputModule, NzInputNumberModule, NzModalModule, NzRadioModule, NzSelectModule, NzSwitchModule, NzTooltipModule];
var COMPONENTS = [SFComponent, SFItemComponent, SFItemWrapComponent, SFTemplateDirective, SFFixedDirective];
var WIDGETS = [ObjectWidget, ArrayWidget, StringWidget, NumberWidget, DateWidget, RadioWidget, CheckboxWidget, BooleanWidget, TextareaWidget, SelectWidget, CustomWidget, TextWidget];
var DelonFormModule = class _DelonFormModule {
  static forRoot() {
    return {
      ngModule: _DelonFormModule,
      providers: [{
        provide: SchemaValidatorFactory,
        useClass: AjvSchemaValidatorFactory,
        deps: [AlainConfigService, NgZone]
      }, {
        provide: WidgetRegistry,
        useClass: NzWidgetRegistry
      }]
    };
  }
  static ɵfac = function DelonFormModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DelonFormModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DelonFormModule,
    declarations: [SFComponent, SFItemComponent, SFItemWrapComponent, SFTemplateDirective, SFFixedDirective, ObjectWidget, ArrayWidget, StringWidget, NumberWidget, DateWidget, RadioWidget, CheckboxWidget, BooleanWidget, TextareaWidget, SelectWidget, CustomWidget, TextWidget],
    imports: [CommonModule, FormsModule, DelonLocaleModule, NzButtonModule, NzCardModule, NzCheckboxModule, NzDatePickerModule, NzFormModule, NzGridModule, NzIconModule, NzInputModule, NzInputNumberModule, NzModalModule, NzRadioModule, NzSelectModule, NzSwitchModule, NzTooltipModule],
    exports: [SFComponent, SFItemComponent, SFItemWrapComponent, SFTemplateDirective, SFFixedDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [CommonModule, FormsModule, DelonLocaleModule, ZORROS]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DelonFormModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, DelonLocaleModule, ...ZORROS],
      declarations: [...COMPONENTS, ...WIDGETS],
      exports: COMPONENTS
    }]
  }], null, null);
})();
var ERRORSDEFAULT = {
  "false schema": `布尔模式出错`,
  $ref: `无法找到引用{ref}`,
  additionalItems: `不允许超过{ref}`,
  additionalProperties: `不允许有额外的属性`,
  anyOf: `数据应为 anyOf 所指定的其中一个`,
  dependencies: `应当拥有属性{property}的依赖属性{deps}`,
  enum: `应当是预设定的枚举值之一`,
  format: `格式不正确`,
  // `应当匹配格式 "{format}"`,
  type: `类型应当是 {type}`,
  required: `必填项`,
  maxLength: `至多 {limit} 个字符`,
  minLength: `至少 {limit} 个字符以上`,
  minimum: `必须 {comparison}{limit}`,
  formatMinimum: `必须 {comparison}{limit}`,
  maximum: `必须 {comparison}{limit}`,
  formatMaximum: `必须 {comparison}{limit}`,
  maxItems: `不应多于 {limit} 个项`,
  minItems: `不应少于 {limit} 个项`,
  maxProperties: `不应多于 {limit} 个属性`,
  minProperties: `不应少于 {limit} 个属性`,
  multipleOf: `应当是 {multipleOf} 的整数倍`,
  not: `不应当匹配 "not" schema`,
  oneOf: `只能匹配一个 "oneOf" 中的 schema`,
  pattern: `数据格式不正确`,
  uniqueItems: `不应当含有重复项 (第 {j} 项与第 {i} 项是重复的)`,
  custom: `格式不正确`,
  propertyNames: `属性名 "{propertyName}" 无效`,
  patternRequired: `应当有属性匹配模式 {missingPattern}`,
  switch: `由于 {caseIndex} 失败，未通过 "switch" 校验`,
  const: `应当等于常量`,
  contains: `应当包含一个有效项`,
  formatExclusiveMaximum: `formatExclusiveMaximum 应当是布尔值`,
  formatExclusiveMinimum: `formatExclusiveMinimum 应当是布尔值`,
  if: `应当匹配模式 "{failingKeyword}"`
};
function provideSFConfig(options) {
  const provides = [{
    provide: SchemaValidatorFactory,
    useClass: AjvSchemaValidatorFactory,
    deps: [AlainConfigService, NgZone]
  }, {
    provide: WidgetRegistry,
    useClass: NzWidgetRegistry
  }];
  if (options?.widgets) {
    provides.push(provideEnvironmentInitializer(() => {
      const srv = inject(WidgetRegistry);
      options?.widgets?.forEach((widget) => srv.register(widget.KEY, widget.type));
    }));
  }
  return makeEnvironmentProviders(provides);
}
export {
  AjvSchemaValidatorFactory,
  ArrayLayoutWidget,
  ArrayProperty,
  ArrayWidget,
  AtomicProperty,
  BooleanProperty,
  BooleanWidget,
  CheckboxWidget,
  ControlUIWidget,
  ControlWidget,
  CustomWidget,
  DateWidget,
  DelonFormModule,
  ERRORSDEFAULT,
  FormProperty,
  FormPropertyFactory,
  NumberProperty,
  NumberWidget,
  NzWidgetRegistry,
  ObjectLayoutWidget,
  ObjectProperty,
  ObjectWidget,
  PropertyGroup,
  RadioWidget,
  SFComponent,
  SFFixedDirective,
  SFItemComponent,
  SFItemWrapComponent,
  SFTemplateDirective,
  SF_DEFAULT_CONFIG,
  SchemaValidatorFactory,
  SelectWidget,
  StringProperty,
  StringWidget,
  TextWidget,
  TextareaWidget,
  Widget,
  WidgetFactory,
  WidgetRegistry,
  di,
  getCopyEnum,
  getData,
  getEnum,
  isBlank,
  isDateFns,
  mergeConfig,
  orderProperties,
  provideSFConfig,
  resolveIfSchema,
  retrieveSchema,
  toBool,
  useFactory
};
//# sourceMappingURL=@delon_form.js.map
