{
  "version": 3,
  "sources": ["../../../../../../node_modules/@delon/util/fesm2022/array.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { inject, Injectable } from '@angular/core';\nimport { AlainConfigService } from '@delon/util/config';\nimport { NzTreeNode } from 'ng-zorro-antd/core/tree';\nclass ArrayService {\n  cogSrv = inject(AlainConfigService);\n  c;\n  constructor() {\n    this.c = this.cogSrv.merge('utilArray', {\n      deepMapName: 'deep',\n      parentMapName: 'parent',\n      idMapName: 'id',\n      parentIdMapName: 'parent_id',\n      childrenMapName: 'children',\n      titleMapName: 'title',\n      checkedMapname: 'checked',\n      selectedMapname: 'selected',\n      expandedMapname: 'expanded',\n      disabledMapname: 'disabled'\n    });\n  }\n  /**\n   * Convert tree structure to array structure\n   *\n   * 将树结构转换成数组结构\n   */\n  treeToArr(tree, options) {\n    const opt = {\n      deepMapName: this.c.deepMapName,\n      parentMapName: this.c.parentMapName,\n      childrenMapName: this.c.childrenMapName,\n      clearChildren: true,\n      cb: null,\n      ...options\n    };\n    const result = [];\n    const inFn = (list, parent, deep = 0) => {\n      for (const i of list) {\n        i[opt.deepMapName] = deep;\n        i[opt.parentMapName] = parent;\n        if (opt.cb) {\n          opt.cb(i, parent, deep);\n        }\n        result.push(i);\n        const children = i[opt.childrenMapName];\n        if (children != null && Array.isArray(children) && children.length > 0) {\n          inFn(children, i, deep + 1);\n        }\n        if (opt.clearChildren) {\n          delete i[opt.childrenMapName];\n        }\n      }\n    };\n    inFn(tree, null);\n    return result;\n  }\n  /**\n   * Convert array structure to tree structure\n   *\n   * 数组转换成树数据\n   */\n  arrToTree(arr, options) {\n    if (!Array.isArray(arr) || arr.length === 0) {\n      return [];\n    }\n    const opt = {\n      idMapName: this.c.idMapName,\n      parentIdMapName: this.c.parentIdMapName,\n      childrenMapName: this.c.childrenMapName,\n      cb: null,\n      ...options\n    };\n    const tree = [];\n    const childrenOf = {};\n    let rootPid = opt.rootParentIdValue;\n    const arrType = arr;\n    if (!rootPid) {\n      const pids = arrType.map(i => i[opt.parentIdMapName]);\n      const emptyPid = pids.findIndex(w => w == null);\n      rootPid = emptyPid !== -1 ? pids[emptyPid] : pids.sort()[0];\n    }\n    for (const item of arrType) {\n      const id = item[opt.idMapName];\n      const pid = item[opt.parentIdMapName];\n      childrenOf[id] = childrenOf[id] || [];\n      item[opt.childrenMapName] = childrenOf[id];\n      if (opt.cb) {\n        opt.cb(item);\n      }\n      if (pid !== rootPid) {\n        childrenOf[pid] = childrenOf[pid] || [];\n        childrenOf[pid].push(item);\n      } else {\n        tree.push(item);\n      }\n    }\n    return tree;\n  }\n  /**\n   * 数组转换成 `nz-tree` 数据源，通过 `options` 转化项名，也可以使用 `options.cb` 更高级决定数据项\n   */\n  arrToTreeNode(arr, options) {\n    const opt = {\n      idMapName: this.c.idMapName,\n      parentIdMapName: this.c.parentIdMapName,\n      titleMapName: this.c.titleMapName,\n      isLeafMapName: 'isLeaf',\n      checkedMapname: this.c.checkedMapname,\n      selectedMapname: this.c.selectedMapname,\n      expandedMapname: this.c.expandedMapname,\n      disabledMapname: this.c.disabledMapname,\n      cb: null,\n      ...options\n    };\n    const tree = this.arrToTree(arr, {\n      idMapName: opt.idMapName,\n      parentIdMapName: opt.parentIdMapName,\n      childrenMapName: 'children'\n    });\n    this.visitTree(tree, (item, parent, deep) => {\n      item.key = item[opt.idMapName];\n      item.title = item[opt.titleMapName];\n      item.checked = item[opt.checkedMapname];\n      item.selected = item[opt.selectedMapname];\n      item.expanded = item[opt.expandedMapname];\n      item.disabled = item[opt.disabledMapname];\n      if (item[opt.isLeafMapName] == null) {\n        item.isLeaf = item.children.length === 0;\n      } else {\n        item.isLeaf = item[opt.isLeafMapName];\n      }\n      if (opt.cb) {\n        opt.cb(item, parent, deep);\n      }\n    });\n    return tree.map(node => new NzTreeNode(node));\n  }\n  /**\n   * 递归访问整个树\n   */\n  visitTree(tree, cb, options) {\n    options = {\n      childrenMapName: this.c.childrenMapName,\n      ...options\n    };\n    const inFn = (data, parent, deep) => {\n      for (const item of data) {\n        cb(item, parent, deep);\n        const childrenVal = item[options.childrenMapName];\n        if (Array.isArray(childrenVal) && childrenVal.length > 0) {\n          inFn(childrenVal, item, deep + 1);\n        }\n      }\n    };\n    inFn(tree, null, 1);\n  }\n  /**\n   * Return the value of the first tree value in the tree where predicate is true, and `undefined` otherwise\n   *\n   * 根据条件返回树的第一个值，否则返回 `undefined`\n   */\n  findTree(tree, predicate, options) {\n    let res;\n    this.visitTree(tree, item => {\n      if (res === undefined && predicate(item)) {\n        res = item;\n      }\n    }, options);\n    return res;\n  }\n  /**\n   * 获取所有已经选中的 `key` 值\n   */\n  getKeysByTreeNode(tree, options) {\n    const opt = {\n      includeHalfChecked: true,\n      ...options\n    };\n    const keys = [];\n    this.visitTree(tree, (item, parent, deep) => {\n      if (item.isChecked || opt.includeHalfChecked && item.isHalfChecked) {\n        keys.push(opt.cb ? opt.cb(item, parent, deep) : opt.keyMapName ? item.origin[opt.keyMapName] : item.key);\n      }\n    });\n    return keys;\n  }\n  baseFlat(array, depth, result = []) {\n    let index = -1;\n    while (++index < array.length) {\n      const value = array[index];\n      if (depth > 0 && Array.isArray(value)) {\n        if (depth > 1) {\n          this.baseFlat(value, depth - 1, result);\n        } else {\n          let pushIndex = -1;\n          const offset = result.length;\n          while (++pushIndex < value.length) {\n            result[offset + pushIndex] = value[pushIndex];\n          }\n        }\n      } else {\n        result[result.length] = value;\n      }\n    }\n    return result;\n  }\n  /**\n   * Recursively flattens array\n   *\n   * 递归扁平数组\n   * ```ts\n   * srv.flat([1, [2, 3, [4, 5, [6]]]]) => [1,2,3,4,5,6]\n   * srv.flat([1, [2, 3, [4, 5, [6]]]], 1) => [1,2,3,[4, 5, [6]]]\n   * ```\n   */\n  flat(array, depth = 1 / 0) {\n    return Array.isArray(array) ? this.baseFlat(array, depth) : array;\n  }\n  /**\n   * Group the array\n   *\n   * 对数组进行分组\n   * ```ts\n   * srv.groupBy([6.1, 4.2, 6.3], Math.floor) => {\"4\":[4.2],\"6\":[6.1,6.3]}\n   * srv.groupBy(['one', 'two', 'three'], v => v.length) => {\"3\":[\"one\",\"two\"],\"5\":[\"three\"]}\n   * ```\n   */\n  groupBy(array, iteratee) {\n    if (!Array.isArray(array)) {\n      return {};\n    }\n    return array.reduce((result, value) => {\n      const key = iteratee(value);\n      if (Object.prototype.hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        result[key] = [value];\n      }\n      return result;\n    }, {});\n  }\n  /**\n   * Creates a duplicate-free version of an array\n   *\n   * 创建去重后的数组\n   * ```ts\n   * uniq([1, 2, 2, 3, 1]) => [1,2,3]\n   * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], 'a') => [{\"a\":1},{\"a\":2}]\n   * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], i => (i.a === 1 ? 'a' : 'b')) => [{\"a\":1},{\"a\":2}]\n   * ```\n   */\n  uniq(array, predicate) {\n    return Array.from(array.reduce((map, value) => {\n      const key = predicate ? typeof predicate === 'string' ? value[predicate] : predicate(value) : value;\n      if (!map.has(key)) {\n        map.set(key, value);\n      }\n      return map;\n    }, new Map()).values());\n  }\n  static ɵfac = function ArrayService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ArrayService)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ArrayService,\n    factory: ArrayService.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ArrayService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ArrayService };\n"],
  "mappings": "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",
  "names": []
}
